<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.50" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <title>2.2 初识表达式 | Modern C++ Primer</title><meta name="description" content="">
    <link rel="preload" href="/modern-cpp-primer/assets/style-CWDAywnZ.css" as="style"><link rel="stylesheet" href="/modern-cpp-primer/assets/style-CWDAywnZ.css">
    <link rel="modulepreload" href="/modern-cpp-primer/assets/app-DNTRvR-x.js"><link rel="modulepreload" href="/modern-cpp-primer/assets/expression.html-LIqFkgzT.js"><link rel="modulepreload" href="/modern-cpp-primer/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/modern-cpp-primer/assets/index.html-DwpCsp6C.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-C-LLjg0v.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-RmKzZAp3.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/cli-program.html-g_fIHQTG.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/declaration.html-Cf5Pjves.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/function.html-6CK8yUX3.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/object.html-D9K1rWhe.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/scope.html-C4VAwKZx.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/statements.html-Bve_WqKZ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-BhsuSVnJ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/hello-world.html-ZiIcINCo.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/id-and-keyword.html-BGPihqY7.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/literals.html-CPg-dTPO.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/punctuators.html-C4JoojMV.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/source-processed.html-Bk9eePd2.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-Dw4xlVZH.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/arithmetic-types.html-C8SUQA9I.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/cv-qualifiers.html-UvcaiCGn.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/overload.html-CT6hHQeg.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/type-intro.html-C1Lni7EH.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/value-category.html-zyMf2ZYN.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/01-container-interface.html-BHYYwGqe.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/02-vector.html-B6_2_AAf.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/03-deque.html-Dq9iIM9e.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/01-compile-stage.html-Dxj3Prfp.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/02-flag-macros.html-CnP1bKfP.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-B36fngnc.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/function-ref.html-BY8GsWa5.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/object-ref.html-B-fLphW6.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/404.html-CAbFH_q2.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-BAnSBO7R.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-yX4Def-e.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-BeqSY4ix.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index-BuTnfdhN.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index-DRWmbcXV.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index-vtyVp-jW.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/mermaid.core-Ce3GxTe7.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/reveal.esm-B3O8JSaZ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/markdown.esm-BcQCyT6L.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/highlight.esm-C34tS8ua.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/math.esm-DN7Rh_EM.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/search.esm-DuBqnxcF.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/notes.esm-YR_UvoMg.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/zoom.esm-Ctj_eavO.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/photoswipe.esm-GXRgw7eJ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/Choices-D9Ltnmki.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/ShikiRenderer-Dfj5L9Cm.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/DecOctHex-DvPipWgd.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/Binary32-D-iTR8gb.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/modern-cpp-primer/zh/"><!----><!----><span class="vp-site-name">Modern C++ Primer</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><!----><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><div class="vp-nav-item"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="选择语言"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon i18n-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="i18n icon" name="i18n" style="width:1rem;height:1rem;vertical-align:middle;"><path d="M379.392 460.8 494.08 575.488l-42.496 102.4L307.2 532.48 138.24 701.44l-71.68-72.704L234.496 460.8l-45.056-45.056c-27.136-27.136-51.2-66.56-66.56-108.544h112.64c7.68 14.336 16.896 27.136 26.112 35.84l45.568 46.08 45.056-45.056C382.976 312.32 409.6 247.808 409.6 204.8H0V102.4h256V0h102.4v102.4h256v102.4H512c0 70.144-37.888 161.28-87.04 210.944L378.88 460.8zM576 870.4 512 1024H409.6l256-614.4H768l256 614.4H921.6l-64-153.6H576zM618.496 768h196.608L716.8 532.48 618.496 768z"></path></svg><!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/modern-cpp-primer/en/" aria-label="English"><!---->English<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/modern-cpp-primer/zh/02-program-structure/expression.html" aria-label="简体中文"><!---->简体中文<!----></a></li></ul></button></div></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/dynilath/moder-cpp-primer" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/" aria-label="Modern C++ Primer"><!---->Modern C++ Primer<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">1 初识 C++</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">2 程序的结构</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/02-program-structure/declaration.html" aria-label="2.1 初识声明，类型与对象"><!---->2.1 初识声明，类型与对象<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/modern-cpp-primer/zh/02-program-structure/expression.html" aria-label="2.2 初识表达式"><!---->2.2 初识表达式<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/02-program-structure/statements.html" aria-label="2.3 初识语句"><!---->2.3 初识语句<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/02-program-structure/function.html" aria-label="2.4 初识函数"><!---->2.4 初识函数<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/02-program-structure/scope.html" aria-label="2.5 初识作用域与命名空间"><!---->2.5 初识作用域与命名空间<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/02-program-structure/object.html" aria-label="2.6 对象与存储期"><!---->2.6 对象与存储期<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/02-program-structure/cli-program.html" aria-label="2.7 简单的控制台程序"><!---->2.7 简单的控制台程序<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">3 类型</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">04 Stl Intro</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">05 Project</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><FontIcon></FontIcon>2.2 初识表达式</h1><div class="page-info"><AuthorInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></AuthorInfo><OriginalInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></OriginalInfo><DateInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></DateInfo><PageViewInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></PageViewInfo><ReadingTimeInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></ReadingTimeInfo><CategoryInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></CategoryInfo><TagInfo localizeddate="2024年6月29日" isoriginal="false" pageview="true" ispure="false"></TagInfo></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#操作数">操作数</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#未定义行为">未定义行为</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#基本表达式">基本表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#后缀表达式">后缀表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#后缀自增运算符">后缀自增运算符</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#后缀自减运算符">后缀自减运算符</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#一元表达式">一元表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#正运算符">正运算符</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#整数提升">整数提升</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#负运算符">负运算符</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#按位取反">按位取反</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#逻辑非">逻辑非</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#前缀自增运算符">前缀自增运算符</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#前缀自减运算符">前缀自减运算符</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#加性表达式和乘性表达式">加性表达式和乘性表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#乘性表达式">乘性表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#加性表达式">加性表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#整数的加减乘除与取余计算">整数的加减乘除与取余计算</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#移位表达式">移位表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#移位表达式的计算">移位表达式的计算</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#关系表达式">关系表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#比较表达式">比较表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#关系表达式-1">关系表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#相等表达式">相等表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#关系表达式与相等表达式的计算">关系表达式与相等表达式的计算</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#比较表达式的计算">比较表达式的计算</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#按位逻辑表达式">按位逻辑表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#按位与">按位与</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#按位异或">按位异或</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#按位或">按位或</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#按位逻辑表达式的计算">按位逻辑表达式的计算</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#逻辑表达式">逻辑表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#逻辑与">逻辑与</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#逻辑或">逻辑或</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#逻辑表达式的计算">逻辑表达式的计算</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#条件表达式">条件表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#赋值表达式">赋值表达式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#赋值表达式的计算">赋值表达式的计算</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#复合赋值表达式">复合赋值表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#副作用">副作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#不确定值">不确定值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#能不能赋值">能不能赋值？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#逗号表达式">逗号表达式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#无法确定顺序的副作用">无法确定顺序的副作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#进一步理解初始化">进一步理解初始化</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#快速练习">快速练习</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><p>表达式是组成 C++ 程序的基本元素之一。<strong>表达式</strong>表示一个计算过程，可以用来计算一个值，以及产生其他影响程序状态的副作用。</p><p>在编译器处理表达式的时候，换行符如同空格一样，当做空白字符处理。因此，换行符不会影响表达式的语义。</p><h2 id="操作数" tabindex="-1"><a class="header-anchor" href="#操作数"><span>操作数</span></a></h2><p>表达式常常由数个表达式和一个运算符组合而成。为了方便理解，我们将这样由运算符和表达式组成的表达式，其中的表达式称为<strong>操作数</strong>。</p><p>对于操作数只有一个的表达式，有如下的形式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // `+` 是运算符，`a` 是操作数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于运算符位于两个操作数之间的表达式，有如下的形式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // `+` 是运算符，`a` 和 `b` 是操作数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，称运算符左边的操作数（上面的 <code>a</code>）为<strong>左操作数</strong>，右边的操作数（上面的 <code>b</code>）为<strong>右操作数</strong>。</p><h2 id="未定义行为" tabindex="-1"><a class="header-anchor" href="#未定义行为"><span>未定义行为</span></a></h2><p>在 C++ 中，有一些编写符合语法，但并不“正确”的程序的行为，称为<strong>未定义行为</strong>。标准没有规定发生未定义行为的程序应该如何运行——这样的行为可能会导致程序崩溃、产生错误的结果、或者产生其他不可预测的行为。</p><p>未定义行为常常是一种在实现和程序编写之间的妥协，当然也有一部分是历史原因遗留的错误设计。</p><div class="hint-container info"><p class="hint-container-title">一种奇妙的模因</p><p>在程序员圈子常常会嘲笑 C++ 的未定义行为。例如，“在作业本里写下1/0，引发了未定义行为从而骗过了老师的检查”，“输入1/0，然后我的程序把我的系统盘格式化了”。</p><p>诚然，未定义行为对于程序设计无疑会带来不少的心智负担，但现实世界里的程序天然运行在一个充满无法预测行为的环境中，与其设计一种“不存在未定义行为”的编程语言，不如想办法让程序员更好地理解未定义行为，这也正是笔者认为 C++ 这种古董语言的最大问题。</p></div><h2 id="基本表达式" tabindex="-1"><a class="header-anchor" href="#基本表达式"><span>基本表达式</span></a></h2><p>基本表达式是表达式的最基本组成部分，通常而言基本表达式是一个整体。基本表达式包括：</p><p>这一节作为入门，只介绍一部分的基本表达式。</p><p><strong>字面量</strong> 组成了一个基本表达式，这个基本表达式的值就是字面量的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 整数字面量 42 组成的基本表达式，值为整数值 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>标识符</strong> 可以是一个基本表达式，它的值是标识符所代表的对象的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 标识符a组成的基本表达式，值为标识符 a 所代表的对象的值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>括号包围的表达式</strong> 也是一个基本表达式，它的值是括号内表达式的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 括号内的整数字面量 42 组成的基本表达式，值为整数值 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 括号内的表达式 a + b 组成的基本表达式，值为 a + b 的值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这个例子里<code>(a + b)</code>是一个基本表达式，但是它里面的表达式却不是基本表达式。那么如何理解基本表达式是一个整体呢？</p><p>不妨考虑这样的结构：<code>(a + b) * c</code>，这个表达式的值是 <code>(a + b)</code> 和 <code>c</code> 进行 <code>*</code> 运算的结果，而不是 <code>a + (b * c)</code> 。这就是基本表达式是一个整体的含义，基本表达式的值只用考虑基本表达式本身，而不用考虑其他组合。</p><div class="hint-container info"><p class="hint-container-title">结合性、优先级与表达式组成的关系</p><p>读者可能会觉得，这不就是数学运算的优先级吗？</p><p>是的，仅考虑算术运算的话，括号的作用就像数学中一样。但是，C++ 中的表达式不仅仅是算术运算，还有很多其他的表达式，有的看起来完全不像个运算；表达式还有一些数学算式所不具有的性质，这都需要对表达式有一个更直观的理解。</p><p>因此，这里采用了表达式结构的形式来解释表达式，而不是数学运算优先级的形式。</p></div><h2 id="后缀表达式" tabindex="-1"><a class="header-anchor" href="#后缀表达式"><span>后缀表达式</span></a></h2><p>这里暂时只介绍下列的三种后缀表达式：</p><ul><li>① <code>基本表达式</code></li><li>② <code>后缀表达式 ++</code></li><li>③ <code>后缀表达式 --</code></li></ul><p>其中 <code>++</code> 表示自增运算符，<code>--</code> 表示自减运算符。由于这是后缀表达式，所以准确的说，这里的 <code>++</code> 是后缀自增运算符，<code>--</code> 是后缀自减运算符。</p><h3 id="后缀自增运算符" tabindex="-1"><a class="header-anchor" href="#后缀自增运算符"><span>后缀自增运算符</span></a></h3><p>后缀自增运算符的作用是，将操作数表示的对象加一，表达式的值是这个对象加一之前的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 a++ 的值是 10，a 的值变为 11</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自增运算。</p><h3 id="后缀自减运算符" tabindex="-1"><a class="header-anchor" href="#后缀自减运算符"><span>后缀自减运算符</span></a></h3><p>后缀自减运算符的作用是，将操作数表示的对象减一，表达式的值是这个对象减一之前的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 a-- 的值是 10，a 的值变为 9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自减运算。</p><h2 id="一元表达式" tabindex="-1"><a class="header-anchor" href="#一元表达式"><span>一元表达式</span></a></h2><p>一元表达式有很多种，这里暂时只介绍其中两种与算术相关的表达式：正运算符和负运算符表达式。其形式为：</p><ul><li><code>+ 一元表达式</code></li><li><code>- 一元表达式</code></li><li><code>~ 一元表达式</code></li><li><code>! 一元表达式</code></li><li><code>++ 一元表达式</code></li><li><code>-- 一元表达式</code></li><li><code>后缀表达式</code></li></ul><p>其中 <code>+</code> 表示正运算符，<code>-</code> 表示负运算符，<code>~</code> 表示按位取反，<code>!</code> 表示逻辑非，<code>++</code> 表示前缀自增运算符，<code>--</code> 表示前缀自减运算符。</p><div class="hint-container info"><p class="hint-container-title">更多一元表达式</p><p>技术性地说，一元表达式形式应当是 <code>+ 转换表达式</code>、<code>- 转换表达式</code>、<code>后缀表达式</code>等。<code>后缀表达式</code> 又由<code>函数调用</code>、<code>数组访问</code>、<code>基本表达式</code>等组成。</p><p>这里为了方便理解，对一元表达式的形式做出了简化，只介绍了一元表达式的一部分。</p></div><h3 id="正运算符" tabindex="-1"><a class="header-anchor" href="#正运算符"><span>正运算符</span></a></h3><p>目前我们只考虑 <code>int</code>、<code>bool</code>、<code>char</code> 这三种基本类型的运算。</p><p>对于 <code>int</code>，正运算符的作用是得到操作数的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意，<code>+a</code>这个表达式虽然值和 <code>a</code> 一样，但是 <code>+a</code> 不同与 <code>a</code>，不再指代 <code>a</code> 所代表的对象，而是另一个和 <code>a</code> 相同的值。</p><h3 id="整数提升" tabindex="-1"><a class="header-anchor" href="#整数提升"><span>整数提升</span></a></h3><p>对于 <code>bool</code> 和 <code>char</code> 类型，正运算符会将其转换为 <code>int</code> 类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 97</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个转换被称为整数提升，类型大小比 <code>int</code> 小的整数类型在正运算符、负运算符的表达式中会被提升为 <code>int</code> 类型。</p><p>后面会介绍到其他的、会发生整数提升的表达式。它们遵循相同的规则，即将类型大小比 <code>int</code> 小的整数类型提升为 <code>int</code> 类型，然后进行计算。</p><h3 id="负运算符" tabindex="-1"><a class="header-anchor" href="#负运算符"><span>负运算符</span></a></h3><p>负运算符的作用是得到操作数的相反数。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>负运算符的作用和正运算符类似，同样会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -97</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，<code>-a</code> 表达式的值和 <code>a</code> 的值相反，但是类似与 <code>+a</code> 并不指代 <code>a</code> 这个对象，<code>-a</code> 并不会改变 <code>a</code> 的值。</p><h3 id="按位取反" tabindex="-1"><a class="header-anchor" href="#按位取反"><span>按位取反</span></a></h3><p>按位取反运算符的作用是对操作数的每一位取反。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -43</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>假设 <code>int</code> 类型是32位的，<code>42</code> 的二进制表示是<code>0000 0000 0000 0000 0000 0000 0010 1010</code>，取反后的二进制表示是<code>1111 1111 1111 1111 1111 1111 1101 0101</code>，转换为十进制就是<code>-43</code>。</p><p>类似于正运算符和负运算符，按位取反运算符也会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -98</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="逻辑非" tabindex="-1"><a class="header-anchor" href="#逻辑非"><span>逻辑非</span></a></h3><p>逻辑非运算符的作用是对操作数取逻辑非，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>逻辑非期待一个 <code>bool</code> 类型的值进行运算，所以这里 <code>42</code> 被转换为 <code>true</code>，然后取逻辑非，结果是 <code>false</code>。</p><h3 id="前缀自增运算符" tabindex="-1"><a class="header-anchor" href="#前缀自增运算符"><span>前缀自增运算符</span></a></h3><p>前缀自增运算符的作用是将操作数表示的对象加一，表达式的值是这个对象加一之后的值、且表示这个对象。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 ++a 的值是 11，a 的值变为 11</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自增运算。</p><h3 id="前缀自减运算符" tabindex="-1"><a class="header-anchor" href="#前缀自减运算符"><span>前缀自减运算符</span></a></h3><p>前缀自减运算符的作用是将操作数表示的对象减一，表达式的值是这个对象减一之后的值、且表示这个对象。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 --a 的值是 9，a 的值变为 9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自减运算。</p><h2 id="加性表达式和乘性表达式" tabindex="-1"><a class="header-anchor" href="#加性表达式和乘性表达式"><span>加性表达式和乘性表达式</span></a></h2><p>加性表达式和乘性表达式组成了 C++ 中，算术表达式的主要形式。</p><h3 id="乘性表达式" tabindex="-1"><a class="header-anchor" href="#乘性表达式"><span>乘性表达式</span></a></h3><p>乘性表达式的形式是</p><ul><li>①<code>乘性表达式 * 一元表达式</code></li><li>②<code>乘性表达式 / 一元表达式</code></li><li>③<code>乘性表达式 % 一元表达式</code></li><li>④<code>一元表达式</code></li></ul><p>根据中间的标点符号类型，乘性表达式的计算不同。<code>*</code>表示乘法，<code>/</code> 表示除法，<code>%</code> 表示取余（模运算）。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的例子里，<code>a</code> 是一个基本表达式，然后以上文④的形式单独组成了一个乘性表达式。<code>(b * c)</code> 也是一个基本表达式，然后 <code>a * (b * c)</code> 以上文①的形式组成了一个乘性表达式。</p><div class="hint-container info"><p class="hint-container-title">乘性表达式的形式</p><p>技术性地说，乘性表达式的形式中的①是 <code>乘性表达式 * 成员指针表达式</code>，②是 <code>乘性表达式 / 成员指针表达式</code>，以此类推。</p><p>从<code>成员指针表达式</code> 到 <code>一元表达式</code> 中间还有一层 <code>转换表达式</code>。</p><p>为了减少引入过多概念导致理解困难，这里简化了乘性表达式的形式。</p></div><h3 id="加性表达式" tabindex="-1"><a class="header-anchor" href="#加性表达式"><span>加性表达式</span></a></h3><p>加性表达式的形式和乘性表达式很类似。加性表达式的形式是</p><ul><li>①<code>加性表达式 + 乘性表达式</code></li><li>②<code>加性表达式 - 乘性表达式</code></li><li>③<code>乘性表达式</code></li></ul><p>根据中间的标点符号类型，加性表达式的计算不同。<code>+</code>表示加法，<code>-</code> 表示减法。</p><p>这时，我们已经能够组合出基本的四则运算了，例如</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>利用一下上面的知识，我们可以对这个表达式做出如下的分析：</p><ul><li><code>a</code>、<code>b</code>、<code>c</code> 都是基本表达式，其值分别是 <code>a</code>、<code>b</code>、<code>c</code> 所代表的对象的值。</li><li><code>b * c</code> 是一个乘性表达式，其值是 <code>b</code> 和 <code>c</code> 的乘法运算的结果。</li><li><code>a + b * c</code> 是一个加性表达式，其值是 <code>a</code> 和 <code>b * c</code> 的加法运算的结果。</li></ul><p>可以画出一个这样的图示来理解</p><!----><p>加性表达式的形式里面并不直接包含一元表达式，所以这里<code>a + b * c</code>的分析结果是唯一的：只能先计算 <code>b * c</code>，然后再计算 <code>a + b * c</code>。否则，就会出现<code>加性表达式 * 乘性表达式</code>的形式，这样无论是加性表达式还是乘性表达式都是不符合规定的。</p><h3 id="整数的加减乘除与取余计算" tabindex="-1"><a class="header-anchor" href="#整数的加减乘除与取余计算"><span>整数的加减乘除与取余计算</span></a></h3><p>在一般的情况下，C++ 中整数的加减乘除和数学上的整数运算是一致的。例如：</p><ul><li><code>42 + 24</code>的值是<code>66</code></li><li><code>42 - 24</code>的值是<code>18</code></li><li><code>42 * 24</code>的值是<code>1008</code></li><li><code>42 / 24</code>的值是<code>1</code></li><li><code>42 % 24</code>的值是<code>18</code>。</li></ul><div class="hint-container info"><p class="hint-container-title">整数除法</p><p>读者可能已经忘记了整数除法的规则，这里简单复习一下。</p><p>整数除法的结果是整数商，还记得“7除以2得3余1”这样的说法吗，整数除法中<code>42 / 24</code>的结果是<code>1</code>，而不是<code>1.75</code>。这里提到的余数，也即是<code>42 % 24</code>得到的<code>18</code>这个结果。</p></div><p>对于除法运算和取余运算，如果除数为0，这个表达式的行为是<a href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p><p>类似于正运算符，加减乘除和取余运算也会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 3</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>int</code> 类型并不是数学意义上的整数，是有范围的，当整数运算的结果超出了 <code>int</code> 类型的范围时，会发生溢出。对于 <code>int</code> 类型，溢出是<a href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。因此，编译器可以认为绝对不会发生溢出，并依此生成代码，这将导致发生溢出时程序的行为不可预测。</p><h2 id="移位表达式" tabindex="-1"><a class="header-anchor" href="#移位表达式"><span>移位表达式</span></a></h2><p>移位表达式的形式是</p><ul><li>①<code>移位表达式 &lt;&lt; 加性表达式</code></li><li>②<code>移位表达式 &gt;&gt; 加性表达式</code></li><li>③<code>加性表达式</code></li></ul><p>其中，<code>&lt;&lt;</code> 表示左移，<code>&gt;&gt;</code> 表示右移。</p><h3 id="移位表达式的计算" tabindex="-1"><a class="header-anchor" href="#移位表达式的计算"><span>移位表达式的计算</span></a></h3><p>移位表达式计算的值是将 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code> 左边的值按照右边的值指定的比特数（位数）进行移位操作的结果。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 168</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>假设 <code>int</code> 是32位的，<code>42</code> 的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0010 1010</code>，左移两位后的二进制表示是 <code>0000 0000 0000 0000 0000 0000 1010 1000</code> （用 <code>0</code> 补充移出来的位），转换为十进制就是 <code>168</code>。</p><p>当结果不超过范围时，读者可以简单地认为左移 <code>N</code> 位就是乘以 <code>2^N</code>。相对的，右移 <code>N</code> 位就是除以 <code>2^N</code>（向下取整）。</p><p>如果左移的结果超过范围，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>42</code>的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0010 1010</code>，左移30位后的二进制表示是 <code>1000 0000 0000 0000 0000 0000 0000 0000</code> （超出范围的位会被舍弃），最后这个结果转换为十进制就是 <code>-2147483648</code>。</p><p>任何情况下，如果移位表达式的右操作数是负数，或者超过了左边值的位数，那么这个表达式的行为是未定义的。</p><p>类似于加性表达式，移位表达式会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 388</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>int</code> 类型的负值，右移操作在左边补充的是 <code>1</code>，而不是 <code>0</code>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -11</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>-42</code> 的二进制表示是 <code>1111 1111 1111 1111 1111 1111 1101 0110</code>，右移两位后的二进制表示是 <code>1111 1111 1111 1111 1111 1111 1111 0101</code>，转换为十进制就是 <code>-11</code>。显然，即使是负数，右移操作也是向下取整的除以 <code>2^N</code>。需要注意，这里的除法是向下取整的，而非向零取整，即 <code>-42 / (2 ^ 2) = -11 ... 3</code>。于是，容易观察到，如果右移时，右操作数的值是左边的位数，正数会变成 <code>0</code>，而负数会变成 <code>-1</code>。</p><div class="hint-container tip"><p class="hint-container-title">移位强迫症</p><p>设计移位是因为在计算机中，移位操作是非常高效的。在一些情况下，移位操作可以取代乘法和除法，从而提高程序的性能。</p><p>然而，了解到这一点的程序员也会强迫自己一定要写出移位操作，这样的做法是不好的。现代编译器能够将整数乘除2的幂次方的操作优化为移位操作，所以不需要强迫自己写出移位操作。</p><p>程序员应当选择适合当前开发情况的代码，在功能开发期使用高可读性容易重构的代码，在维护优化期使用性能更高的代码。当然，我们最希望的事情是这两个目标能够并行不悖。</p></div><h2 id="关系表达式" tabindex="-1"><a class="header-anchor" href="#关系表达式"><span>关系表达式</span></a></h2><p><strong>比较表达式</strong>、<strong>关系表达式</strong>、<strong>相等表达式</strong>三者组成了 C++ 中的比较关系，它们的形式如下：</p><h3 id="比较表达式" tabindex="-1"><a class="header-anchor" href="#比较表达式"><span>比较表达式</span></a></h3><ul><li>① <code>比较表达式 &lt;=&gt; 移位表达式</code></li><li>② <code>移位表达式</code></li></ul><h3 id="关系表达式-1" tabindex="-1"><a class="header-anchor" href="#关系表达式-1"><span>关系表达式</span></a></h3><ul><li>① <code>关系表达式 &lt; 比较表达式</code></li><li>② <code>关系表达式 &gt; 比较表达式</code></li><li>③ <code>关系表达式 &lt;= 比较表达式</code></li><li>④ <code>关系表达式 &gt;= 比较表达式</code></li><li>⑤ <code>比较表达式</code></li></ul><p>其中，<code>&lt;</code> 表示小于，<code>&gt;</code> 表示大于，<code>&lt;=</code> 表示小于等于，<code>&gt;=</code> 表示大于等于。</p><h3 id="相等表达式" tabindex="-1"><a class="header-anchor" href="#相等表达式"><span>相等表达式</span></a></h3><ul><li>① <code>相等表达式 == 关系表达式</code></li><li>② <code>相等表达式 != 关系表达式</code></li><li>③ <code>关系表达式</code></li></ul><p>其中，<code>==</code> 表示等于，<code>!=</code> 表示不等于。注意，表示等于时，中间的运算符是两个等号 <code>==</code>，而不是一个等号 <code>=</code>。</p><h3 id="关系表达式与相等表达式的计算" tabindex="-1"><a class="header-anchor" href="#关系表达式与相等表达式的计算"><span>关系表达式与相等表达式的计算</span></a></h3><p>比较表达式和关系表达式的结果都是 <code>bool</code> 类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果两边的表达式的类型不同，C++ 会尝试将两边转换为类型大小较大的那个类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，<code>&#39;a&#39;</code> 被转换为 <code>int</code> 类型，然后再进行比较。<code>&#39;a&#39;</code>的ASCII码是65，所以这个比较的结果是 <code>65 &lt; 42</code>，得到 <code>false</code>。</p><p>注意，不要连用两个比较运算符，例如<code>24 &lt; a &lt; 42</code>。这样的表达式会导致计算 <code>24 &lt; a</code> 的结果，得到一个 <code>bool</code> 值，然后这个值（假定为<code>x</code>）再计算 <code>x &lt; 42</code>。这样的计算中，<code>bool</code> 被转换为 <code>int</code> 类型（因为比较的右边是 <code>int</code> 类型），结果<code>x</code>要么是<code>0</code> 要么是 <code>1</code>，然后和 <code>42</code> 比较，这显然不会得到我们想要的结果。</p><h3 id="比较表达式的计算" tabindex="-1"><a class="header-anchor" href="#比较表达式的计算"><span>比较表达式的计算</span></a></h3><p><code>&lt;=&gt;</code> 表示三路比较，<code>&lt;=&gt;</code> 的结果是一个整数，如果左边的值小于右边的值，结果是负数；如果左边的值等于右边的值，结果是0；如果左边的值大于右边的值，结果是正数。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">三路比较是什么？</p><p>技术性地说，<code>int</code> 类型的三路比较的结果是一个 <code>std::strong_ordering</code> 类型的值，包括 <code>less</code>、<code>equal</code>、<code>greater</code> 三个值，这三个值可以与0做比较。这里为了方便理解，简化了三路比较的结果。</p><p><code>std::strong_ordering</code> 表达的是全序关系。对于某个具有全序关系的类型的值 <code>a</code> 、 <code>b</code> 和 <code>c</code>，有：</p><ul><li>反对称性：如果 <code>a &lt;= b</code> 且 <code>b &lt;= a</code> 成立，那么 <code>a == b</code>。</li><li>传递性：如果 <code>a &lt;= b</code> 且 <code>b &lt;= c</code>，那么 <code>a &lt;= c</code>。</li><li>反自反性：<code>a &lt;= a</code> 总是成立。</li></ul><p>这时候，两个数据的比较常常能够用差值的符号性来表示，这样能最大程度利用一次比较的信息量。</p><p>除了全序关系，还有偏序关系 <code>std::partial_ordering</code> 和弱序关系 <code>std::weak_ordering</code>。偏序关系允许类型中存在两个值之间没有比较关系，弱序关系则可以忽略传递性。</p></div><h2 id="按位逻辑表达式" tabindex="-1"><a class="header-anchor" href="#按位逻辑表达式"><span>按位逻辑表达式</span></a></h2><p>按位逻辑表达式有三种：按位与、按位或和按位异或。</p><h3 id="按位与" tabindex="-1"><a class="header-anchor" href="#按位与"><span>按位与</span></a></h3><ul><li>①<code>按位与表达式 &amp; 相等表达式</code></li><li>②<code>相等表达式</code></li></ul><h3 id="按位异或" tabindex="-1"><a class="header-anchor" href="#按位异或"><span>按位异或</span></a></h3><ul><li><code>按位异或表达式 ^ 按位与表达式</code></li><li><code>按位与表达式</code></li></ul><h3 id="按位或" tabindex="-1"><a class="header-anchor" href="#按位或"><span>按位或</span></a></h3><ul><li>①<code>按位或表达式 | 按位异或表达式</code></li><li>②<code>按位异或表达式</code></li></ul><h3 id="按位逻辑表达式的计算" tabindex="-1"><a class="header-anchor" href="#按位逻辑表达式的计算"><span>按位逻辑表达式的计算</span></a></h3><p>按位逻辑表达式的计算是将 <code>&amp;</code>、<code>^</code>、<code>|</code> 左右两边的值按每一位分别进行逻辑运算的结果。</p><p>对于一个比特而言：</p><ul><li>按位与的结果是两个比特都为1时结果为1，否则为0。</li><li>按位或的结果是两个比特都为0时结果为0，否则为1。</li><li>按位异或的结果是两个比特相同时结果为0，否则为1。</li></ul><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 8</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 58</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 50</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>42</code> 的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0010 1010</code>，<code>24</code> 的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0001 1000</code>，按位与的结果是 <code>0000 0000 0000 0000 0000 0000 0000 1000</code>，转换为十进制就是 <code>8</code>。</p><p>按位逻辑表达式会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 99</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="逻辑表达式" tabindex="-1"><a class="header-anchor" href="#逻辑表达式"><span>逻辑表达式</span></a></h2><p>逻辑表达式有两种：逻辑与和逻辑或。</p><h3 id="逻辑与" tabindex="-1"><a class="header-anchor" href="#逻辑与"><span>逻辑与</span></a></h3><ul><li>①<code>逻辑与表达式 &amp;&amp; 按位或表达式</code></li><li>②<code>按位或表达式</code></li></ul><h3 id="逻辑或" tabindex="-1"><a class="header-anchor" href="#逻辑或"><span>逻辑或</span></a></h3><ul><li>①<code>逻辑或表达式 || 逻辑与表达式</code></li><li>②<code>逻辑与表达式</code></li></ul><h3 id="逻辑表达式的计算" tabindex="-1"><a class="header-anchor" href="#逻辑表达式的计算"><span>逻辑表达式的计算</span></a></h3><p>逻辑表达式的计算是将 <code>&amp;&amp;</code>、<code>||</code> 左右两边的值按照逻辑运算的结果。这会将左右两边的值转换为 <code>bool</code> 类型，然后进行逻辑运算。</p><p>其中：</p><ul><li>逻辑与的结果是两个值都为 <code>true</code> 时结果为 <code>true</code>，否则为 <code>false</code>。</li><li>逻辑或的结果是两个值都为 <code>false</code> 时结果为 <code>false</code>，否则为 <code>true</code>。</li></ul><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，逻辑表达式是短路的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值一定是 <code>false</code>，因为逻辑与的左边是 <code>false</code>。此时，C++规定不会计算右边<code>a</code>的值，直接返回 <code>false</code>。类似的，如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值一定是 <code>true</code>，因为逻辑或的左边是 <code>true</code>。此时，C++规定不会计算右边<code>a</code>的值，直接返回 <code>true</code>。</p><p>在之后，当我们了解到表达式的副作用时，我们会进一步讨论逻辑表达式的短路。</p><div class="hint-container tip"><p class="hint-container-title">逻辑表达式的计算顺序</p><p>读者可以发现，从关系表达式到逻辑表达式，有着一层一层严格的组合关系。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式被唯一解释为如下图的计算过程：</p><!----><p>现在正看着这个文档的人可能会觉得这个计算顺序很明显。但是在开发的时候，每写一个表达式都要考虑计算顺序，是一件非常繁琐且降低效率的事情。</p><p>与其把时间消耗在反复训练以熟练掌握这个计算顺序，不如把时间消耗在提高代码质量上。在实际开发中，我们可以多用<code>()</code>括号，将复杂的组合表达式变为基本表达式。这样，不仅解决了计算顺序的问题，还可以提高代码的可读性。</p><p>例如，上面的表达式可以写成：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样计算顺序就变得非常明显了。</p></div><h2 id="条件表达式" tabindex="-1"><a class="header-anchor" href="#条件表达式"><span>条件表达式</span></a></h2><p>C++ 中的条件表达式又叫做三目运算、三元表达式等名称，其形式是</p><ul><li>① <code>逻辑或表达式</code></li><li>② <code>逻辑或表达式 ? 表达式 : 赋值表达式</code></li></ul><p>标点符号 <code>?</code> 和 <code>:</code> 是条件表达式的标志，为了方便表述，这里将 <code>?</code> 左边的表达式称为 操作数1，将 <code>:</code> 左边、<code>?</code> 右边的表达式称为 操作数2，将 <code>:</code> 右边的表达式称为 操作数3。</p><p>条件表达式的计算是先计算操作数1，如果操作数1转换到<code>bool</code>后的值<code>true</code>，则计算操作数2，否则计算操作数3（类似于逻辑表达式的短路行为，另一个操作数不会计算）。</p><p>整个表达式的值是操作数2或操作数3的值，取决于计算了哪一个操作数。</p><h2 id="赋值表达式" tabindex="-1"><a class="header-anchor" href="#赋值表达式"><span>赋值表达式</span></a></h2><p>赋值表达式的形式是：</p><ul><li>①<code>条件表达式</code></li><li>②<code>逻辑或表达式 = 赋值表达式</code></li></ul><p>以及一系列的复合赋值表达式：</p><ul><li>③<code>逻辑或表达式 += 赋值表达式</code></li><li>④<code>逻辑或表达式 -= 赋值表达式</code></li><li>⑤<code>逻辑或表达式 *= 赋值表达式</code></li><li>⑥<code>逻辑或表达式 /= 赋值表达式</code></li><li>⑦<code>逻辑或表达式 %= 赋值表达式</code></li><li>⑧<code>逻辑或表达式 &lt;&lt;= 赋值表达式</code></li><li>⑨<code>逻辑或表达式 &gt;&gt;= 赋值表达式</code></li><li>⑩<code>逻辑或表达式 &amp;= 赋值表达式</code></li><li>⑪<code>逻辑或表达式 ^= 赋值表达式</code></li><li>⑫<code>逻辑或表达式 |= 赋值表达式</code></li></ul><h3 id="赋值表达式的计算" tabindex="-1"><a class="header-anchor" href="#赋值表达式的计算"><span>赋值表达式的计算</span></a></h3><p>赋值是 C++ 中一种操作的名称，对于 <code>int</code>、<code>bool</code>、<code>char</code> 这三种基本类型，赋值的操作是将一个对象的值改变为另一个值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的作用是将 <code>a</code> 的值改变为 <code>42</code>。对于②形式的赋值表达式，其计算是先计算右边的赋值表达式，然后将计算结果赋值给左边的逻辑或表达式。</p><div class="hint-container info"><p class="hint-container-title">等于号</p><p>在数学中，等于号有很多含义，例如定义函数、表示等价、表示等于关系。但是在 C++ 中，等于号的含义是赋值。这个含义与数学中任何含义都不同，对于初学者需要注意。</p></div><p>赋值表达式的值是赋值完成后 <code>=</code> 左边的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式的值为 42，并表示 a 这个对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这意味着可以写出如下的表达式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 <code>a</code> 先被赋值为 <code>42</code>，然后再被赋值为 <code>24</code>。这个表达式的值是 <code>24</code>。</p><p>注意，赋值表达式的组合方式和前面的表达式不同。例如，加性表达式的结构是</p><ul><li>①<code>加性表达式 + 乘性表达式</code></li></ul><p>这里加性表达式在左边，乘性表达式在右边。而赋值表达式的结构是</p><ul><li>②<code>逻辑或表达式 = 赋值表达式</code></li></ul><p>这里赋值表达式在左边，逻辑或表达式在右边。</p><p>考虑如下的表达式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个赋值表达式的结构实际上是</p><!----><p>也即是说，这个表达式会先计算 <code>b = 42</code>，然后再计算 <code>a = b = 42</code>。也即从右往左计算的。</p><h3 id="复合赋值表达式" tabindex="-1"><a class="header-anchor" href="#复合赋值表达式"><span>复合赋值表达式</span></a></h3><p>复合赋值表达式是复合操作的赋值表达式，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>等价于</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>技术性地说，对于 <code>op</code> 运算符，<code>a op= b</code> 等价于 <code>a = a op b</code>。除了这里的 <code>a</code> 表达式只计算一次，其他的计算过程和先计算再赋值时是一样的。</p><h3 id="副作用" tabindex="-1"><a class="header-anchor" href="#副作用"><span>副作用</span></a></h3><p>在 C++ 中，表达式的计算可能会产生副作用，副作用会影响表达式以外的程序部分。</p><p>除了赋值表达式，前面介绍过的<a href="#%E5%89%8D%E7%BC%80%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6">前缀自增运算符</a>、<a href="#%E5%89%8D%E7%BC%80%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">前缀自减运算符</a>、<a href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6">后缀自增运算符</a>、<a href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">后缀自减运算符</a>也能产生副作用。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式除了会改变 <code>b</code> 的值，还会改变 <code>a</code> 的值。这里的 <code>a = 42</code> 是一个赋值表达式，它的值是 <code>42</code>，然后再计算 <code>42 + 24</code>，最后将结果 <code>66</code> 赋值给 <code>b</code>。</p><p>赋值表达式规定了先计算右边的表达式，再计算左边的表达式，最后进行赋值。这样的规定使得如<code>a += a += 1</code>这样的表达式是符合语法的，这里的计算过程是先计算右边的<code>a += 1</code>，得到这个表达式的值<code>x</code>，然后再计算左边的<code>a += x</code>。但显然这样的表达式的可读性比较糟糕，在开发中应当避免这样使用。</p><p>在前面逻辑表达式的短路中，我们提到了逻辑表达式的短路行为。这种短路行为会导致逻辑表达式的副作用不会发生。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值是 <code>false</code>，并且 <code>a = 42</code> 不会计算，<code>a</code> 的值不会改变。类似的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值是 <code>true</code>，并且 <code>a = 42</code> 不会计算，<code>a</code> 的值不会改变。</p><h3 id="不确定值" tabindex="-1"><a class="header-anchor" href="#不确定值"><span>不确定值</span></a></h3><p>在初识声明的<!---->一节中提到，如果一个对象声明时没有初始化器，则会初始化为不确定值。</p><p>虽然不能使用具有不确定值的对象的值，但是可以对其进行赋值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是不确定的</span></span>
<span class="line highlighted error"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// int b = a;// 错误，不能使用 a 的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可以对 a 进行赋值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 现在 a 的值是确定的，可以使用 a 的值了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="能不能赋值" tabindex="-1"><a class="header-anchor" href="#能不能赋值"><span>能不能赋值？</span></a></h3><p>赋值表达式的左边并不能是任意的表达式，例如</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是因为 <code>a + b</code> 得到的是一个临时的值，并不指代对象，所以不能对其赋值。赋值表达式的左边必须是一个能够指代对象的表达式。</p><p>在这一节中，已经提到了前缀自增、前缀自减、赋值表达式、复合赋值表达式等表达式的值是能指代对象的。这意味着下面的表达式是符合语法的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相对的后缀自增、后缀自减、取反运算符等表达式会导致表达式不再能赋值。注意，<a href="#%E6%AD%A3%E8%BF%90%E7%AE%97%E7%AC%A6">正运算符</a>对于 <code>int</code> 类型虽然不会让值发生变化，但也是如此。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span>
<span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span>
<span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span>
<span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，前缀自增、前缀自减、后缀自增、后缀自减等表达式对参数做出修改，性质上也是赋值。这意味着其操作数如果不是可赋值的，则会产生错误。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">前缀与后缀的差异</p><p>前缀自增、前缀自减、后缀自增、后缀自减的差异是延续自 C 语言的设计。</p><p>早年编译器优化能力的匮乏使得程序员之间流传着 “后缀自增会产生一个临时对象从而损失性能” 的传说，在 21 世纪，这种传说已经不再成立。</p><p>自增自减的这种差异也常常会带来阅读上的困扰，因此在实际开发中，应当尽可能简略且明确地使用自增自减，避免把它结合进复杂的表达式中。</p></div><p>此外，如果 <code>()</code> 内的表达式是能指代对象的，那么这个基础表达式也指代这个对象，从而可以赋值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，如果<a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件表达式</a>的操作数2和操作数3能指代对象，且是相同的类型，那么条件表达式的值也是能指代对象的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，赋值表达式左边不能直接是条件表达式，需要使用括号将它变成基础表达式</p><h2 id="逗号表达式" tabindex="-1"><a class="header-anchor" href="#逗号表达式"><span>逗号表达式</span></a></h2><p>逗号表达式的形式是</p><ul><li>①<code>逗号表达式 , 赋值表达式</code></li><li>②<code>赋值表达式</code></li></ul><p>这里将逗号表达式中，&#39;,&#39;的左边称为操作数1，右边称为操作数2。</p><p>逗号表达式的计算是先计算操作数1，然后计算操作数2，最后返回操作数2的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>逗号表达式也可以连续使用，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 66</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 66</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>注意，在特定语境下，逗号不会被解释为逗号表达式。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的逗号不是逗号表达式，而是用来分隔不同的声明的。</p><p>除此之外还有函数调用、初始化列表等语境下，逗号也不会被解释为逗号表达式。这些内容会在后续章节中介绍。</p></div><h2 id="无法确定顺序的副作用" tabindex="-1"><a class="header-anchor" href="#无法确定顺序的副作用"><span>无法确定顺序的副作用</span></a></h2><p>在本节前面的内容中，介绍了一些有序的表达式，例如赋值表达式、复合赋值表达式、逗号表达式等。这样的表达式中，出现了多个对相同对象的副作用时，其作用是确定的，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // i 的值是 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的赋值表达式，先计算左边表达式，再计算右边表达式，最后赋值。其计算过程是：</p><ol><li>先计算左边，<code>i</code> 表达式的值是 <code>1</code>，且表示 <code>i</code> 对象。</li><li>再计算右边，<code>++i + 2</code> 表达式的值是 <code>4</code>，发生副作用，<code>i</code> 的值变为 <code>2</code>。</li><li>最后赋值，<code>i</code> 的值变为 <code>4</code>。</li></ol><p>但是，并不是所有的表达式都是有序的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 <code>++i</code> 和 <code>i++</code> 都会对 <code>i</code> 产生副作用，但是 C++ 规定 <code>+</code> 两边的表达式的计算是无顺序的。</p><p>对这样的表达式求值是错误的，无论是在学习还是在实际开发中，都应当避免写出这样的表达式。</p><h2 id="进一步理解初始化" tabindex="-1"><a class="header-anchor" href="#进一步理解初始化"><span>进一步理解初始化</span></a></h2><p>在前文，我们提到初始化的概念，声明并初始化的语法结构是：<code>类型 标识符 初始化器;</code></p><p>之前我们认为初始化器是<code>= 字面量</code>，例如<code>int a = 42;</code>，<code>= 42</code>就是初始化器。现在，我们可以进一步理解初始化器，初始化器可以是<code>= 赋值表达式</code>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里b的初始化器是<code>= 42 + a</code>，这个初始化器是<code>= 表达式</code>，这个生命会将<code>b</code>指代的对象初始化为<code>42 + a</code>的值。</p><p>初始化器中能出现赋值表达式（当然也因此而包括了赋值表达式所有的组件）。这意味着下列代码是符合语法的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，由于初始化器是<code>= 赋值表达式</code>，所以初始化器中不能出现逗号表达式。初始化器中的逗号有另外的含义，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的逗号不是逗号表达式，而是分隔了两个声明。这里分别声明了<code>a</code>和<code>b</code>，并分别初始化为<code>42</code>和<code>24</code>。</p><p>我们可以把以下两种形式统称为初始化声明</p><ul><li><code>标识符</code></li><li><code>标识符 = 赋值表达式</code></li></ul><p>那么，初始化就可以理解为</p><p><code>类型 初始化声明 , 初始化声明 , 初始化声明 ... ;</code></p><p>这样的结构，到此已经基本接近了完整的 C++ 初始化语法。</p><h2 id="快速练习" tabindex="-1"><a class="header-anchor" href="#快速练习"><span>快速练习</span></a></h2><!----></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/dynilath/moder-cpp-primer/edit/main/src/zh/02-program-structure/expression.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: dynilath@qq.com">dynilath</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/modern-cpp-primer/zh/02-program-structure/declaration.html" aria-label="2.1 初识声明，类型与对象"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><FontIcon></FontIcon>2.1 初识声明，类型与对象</div></a><a class="route-link auto-link next" href="/modern-cpp-primer/zh/02-program-structure/statements.html" aria-label="2.3 初识语句"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">2.3 初识语句<FontIcon></FontIcon></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/modern-cpp-primer/assets/app-DNTRvR-x.js" defer></script>
  </body>
</html>
