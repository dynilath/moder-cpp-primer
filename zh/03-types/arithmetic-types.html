<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.50" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <title>3.2 算术类型 | Modern C++ Primer</title><meta name="description" content="">
    <link rel="preload" href="/modern-cpp-primer/assets/style-CWDAywnZ.css" as="style"><link rel="stylesheet" href="/modern-cpp-primer/assets/style-CWDAywnZ.css">
    <link rel="modulepreload" href="/modern-cpp-primer/assets/app-DNTRvR-x.js"><link rel="modulepreload" href="/modern-cpp-primer/assets/arithmetic-types.html-C8SUQA9I.js"><link rel="modulepreload" href="/modern-cpp-primer/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/modern-cpp-primer/assets/index.html-DwpCsp6C.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-C-LLjg0v.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-RmKzZAp3.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/cli-program.html-g_fIHQTG.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/declaration.html-Cf5Pjves.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/expression.html-LIqFkgzT.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/function.html-6CK8yUX3.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/object.html-D9K1rWhe.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/scope.html-C4VAwKZx.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/statements.html-Bve_WqKZ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-BhsuSVnJ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/hello-world.html-ZiIcINCo.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/id-and-keyword.html-BGPihqY7.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/literals.html-CPg-dTPO.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/punctuators.html-C4JoojMV.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/source-processed.html-Bk9eePd2.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-Dw4xlVZH.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/cv-qualifiers.html-UvcaiCGn.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/overload.html-CT6hHQeg.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/type-intro.html-C1Lni7EH.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/value-category.html-zyMf2ZYN.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/01-container-interface.html-BHYYwGqe.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/02-vector.html-B6_2_AAf.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/03-deque.html-Dq9iIM9e.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/01-compile-stage.html-Dxj3Prfp.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/02-flag-macros.html-CnP1bKfP.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-B36fngnc.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/function-ref.html-BY8GsWa5.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/object-ref.html-B-fLphW6.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/404.html-CAbFH_q2.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-BAnSBO7R.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-yX4Def-e.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index.html-BeqSY4ix.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index-BuTnfdhN.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index-DRWmbcXV.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/index-vtyVp-jW.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/mermaid.core-Ce3GxTe7.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/reveal.esm-B3O8JSaZ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/markdown.esm-BcQCyT6L.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/highlight.esm-C34tS8ua.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/math.esm-DN7Rh_EM.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/search.esm-DuBqnxcF.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/notes.esm-YR_UvoMg.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/zoom.esm-Ctj_eavO.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/photoswipe.esm-GXRgw7eJ.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/Choices-D9Ltnmki.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/ShikiRenderer-Dfj5L9Cm.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/DecOctHex-DvPipWgd.js" as="script"><link rel="prefetch" href="/modern-cpp-primer/assets/Binary32-D-iTR8gb.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/modern-cpp-primer/zh/"><!----><!----><span class="vp-site-name">Modern C++ Primer</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><!----><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><div class="vp-nav-item"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="选择语言"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon i18n-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="i18n icon" name="i18n" style="width:1rem;height:1rem;vertical-align:middle;"><path d="M379.392 460.8 494.08 575.488l-42.496 102.4L307.2 532.48 138.24 701.44l-71.68-72.704L234.496 460.8l-45.056-45.056c-27.136-27.136-51.2-66.56-66.56-108.544h112.64c7.68 14.336 16.896 27.136 26.112 35.84l45.568 46.08 45.056-45.056C382.976 312.32 409.6 247.808 409.6 204.8H0V102.4h256V0h102.4v102.4h256v102.4H512c0 70.144-37.888 161.28-87.04 210.944L378.88 460.8zM576 870.4 512 1024H409.6l256-614.4H768l256 614.4H921.6l-64-153.6H576zM618.496 768h196.608L716.8 532.48 618.496 768z"></path></svg><!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/modern-cpp-primer/en/" aria-label="English"><!---->English<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/modern-cpp-primer/zh/03-types/arithmetic-types.html" aria-label="简体中文"><!---->简体中文<!----></a></li></ul></button></div></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/dynilath/moder-cpp-primer" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/" aria-label="Modern C++ Primer"><!---->Modern C++ Primer<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">1 初识 C++</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">2 程序的结构</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">3 类型</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/03-types/type-intro.html" aria-label="3.1 类型概述"><!---->3.1 类型概述<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/modern-cpp-primer/zh/03-types/arithmetic-types.html" aria-label="3.2 算术类型"><!---->3.2 算术类型<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/03-types/cv-qualifiers.html" aria-label="3.3 const 与 volatile 限定符"><!---->3.3 const 与 volatile 限定符<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/03-types/value-category.html" aria-label="3.4 值类别"><!---->3.4 值类别<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">3.5 引用类型</span><span class="vp-arrow end"></span></button><!----></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/modern-cpp-primer/zh/03-types/overload.html" aria-label="3.6 初识重载"><!---->3.6 初识重载<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">04 Stl Intro</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><FontIcon></FontIcon><span class="vp-sidebar-title">05 Project</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><FontIcon></FontIcon>3.2 算术类型</h1><div class="page-info"><AuthorInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></AuthorInfo><OriginalInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></OriginalInfo><DateInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></DateInfo><PageViewInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></PageViewInfo><ReadingTimeInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></ReadingTimeInfo><CategoryInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></CategoryInfo><TagInfo localizeddate="2024年7月2日" isoriginal="false" pageview="true" ispure="false"></TagInfo></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#整数类型">整数类型</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#一些实现的类型大小">一些实现的类型大小</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#扩展整数类型">扩展整数类型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#整数类型的运算">整数类型的运算</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#整数提升">整数提升</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#整数转换">整数转换</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#浮点类型">浮点类型</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#标准浮点类型">标准浮点类型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#扩展浮点类型">扩展浮点类型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#浮点计算">浮点计算</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#特殊浮点值">特殊浮点值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#浮点舍入">浮点舍入</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#浮点转换">浮点转换</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#一般算术转换">一般算术转换</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#转换等级">转换等级</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#一般算术转换-1">一般算术转换</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><p>算术类型是一类能对数据进行算术运算的类型。C++ 中的算术类型包括<strong>整数类型</strong>和<strong>浮点类型</strong>。</p><h2 id="整数类型" tabindex="-1"><a class="header-anchor" href="#整数类型"><span>整数类型</span></a></h2><p>在前面的章节中，为了介绍表达式，介绍了三种类型 <code>int</code>、<code>bool</code> 和 <code>char</code>，这些类型都是整数类型。这里我们详细介绍整数类型。</p><p>C++ 中默认提供的整数类型包括：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型大小</th></tr></thead><tbody><tr><td><code>short int</code></td><td>短整数类型</td><td>没有字面量</td><td>至少 2</td></tr><tr><td><code>unsigned short int</code></td><td>无符号短整数类型</td><td>没有字面量</td><td>至少 2</td></tr><tr><td><code>int</code></td><td>整数类型</td><td><code>123</code>，没有后缀</td><td>至少 2，且不小于 <code>short</code>。</td></tr><tr><td><code>unsigned int</code></td><td>无符号整数类型</td><td><code>123u</code>，后缀<code>u</code>，不区分大小写</td><td>至少 2，且不小于 <code>short</code>。</td></tr><tr><td><code>long int</code></td><td>长整数类型</td><td><code>123l</code>，后缀<code>l</code>，不区分大小写</td><td>至少 4，且不小于 <code>int</code>。</td></tr><tr><td><code>unsigned long int</code></td><td>无符号长整数类型</td><td><code>123ul</code>，后缀<code>ul</code>，不区分大小写</td><td>至少 4，且不小于 <code>int</code>。</td></tr><tr><td><code>long long int</code></td><td>长长整数类型</td><td><code>123ll</code>，后缀<code>ll</code>，不区分大小写</td><td>至少 8，且不小于 <code>long</code>。</td></tr><tr><td><code>unsigned long long int</code></td><td>无符号长长整数类型</td><td><code>123ull</code>，后缀<code>ull</code>，不区分大小写</td><td>至少 8，且不小于 <code>long</code>。</td></tr></tbody></table><p>上面提到的这些类型，字面量的后缀 <code>u</code>、<code>l</code>、<code>ll</code> 不区分大小写，并且 <code>u</code> 和 <code>l</code> / <code>ll</code> 的顺序任意，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">U</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 值为123，类型为 unsigned int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 unsigned long int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">lu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 unsigned long int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 long long int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LLU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 unsigned long long int</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，不可以写作 <code>123lul</code></p><p>上面描述的这些类型的名字由多个关键字组成，其中的一部分是可以省略、或者无影响地添加的：</p><table><thead><tr><th>类型</th><th>等同的类型</th><th>最短形式</th></tr></thead><tbody><tr><td><code>short int</code></td><td><code>short</code>、<code>signed short</code>、<code>signed short int</code></td><td><code>short</code></td></tr><tr><td><code>unsigned short int</code></td><td><code>unsigned short</code></td><td><code>unsigned short</code></td></tr><tr><td><code>int</code></td><td><code>signed</code>、<code>signed int</code></td><td><code>int</code></td></tr><tr><td><code>unsigned int</code></td><td><code>unsigned</code></td><td><code>unsigned</code></td></tr><tr><td><code>long int</code></td><td><code>long</code>、<code>signed long</code>、<code>signed long int</code></td><td><code>long</code></td></tr><tr><td><code>unsigned long int</code></td><td><code>unsigned long</code></td><td><code>unsigned long</code></td></tr></tbody></table><p>组成这些类型关键词顺序是任意的，例如 <code>signed int</code> 和 <code>int signed</code> 是等价的、<code>unsigned long long int</code> 和 <code>int long unsigned long</code> 也是等价的。</p><div class="hint-container info"><p class="hint-container-title">语言习惯</p><p>上面提到的 <code>int long unsigned long</code> 虽然是符合语法的，但是人类在描述一件事物的时候，使用限定语通常会有一定的顺序。例如“一个大圆红苹果”很少有人会说成“红大一个圆苹果”。在使用多关键词类型名的时候，往往习惯于按照符号性、大小、中心词<code>int</code>的顺序来描述类型。</p></div><p>前面提到过了<!---->，类型别名不能将这样多个关键字组成的类型拆开，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将 my_int 定义为 int 的别名</span></span>
<span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_int x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：long my_int 不能组成 long int</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上述用于表示基本整数的类型，C++ 还提供了一些用于表示字符的整数类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型大小</th></tr></thead><tbody><tr><td><code>signed char</code></td><td>有符号字符类型</td><td>没有字面量</td><td>1</td></tr><tr><td><code>unsigned char</code></td><td>无符号字符类型</td><td>没有字面量</td><td>1</td></tr><tr><td><code>char</code></td><td>字符类型</td><td><code>&#39;A&#39;</code></td><td>1</td></tr><tr><td><code>char8_t</code></td><td>UTF-8 字符类型</td><td><code>u8&#39;A&#39;</code>，u8前缀</td><td>1，与 <code>unsigned char</code> 相同</td></tr><tr><td><code>char16_t</code></td><td>UTF-16 字符类型</td><td><code>u&#39;A&#39;</code>，u前缀</td><td>与 <code>std::uint_least16_t</code> 相同</td></tr><tr><td><code>char32_t</code></td><td>UTF-32 字符类型</td><td><code>U&#39;A&#39;</code>，大写U前缀</td><td>与 <code>std::uint_least32_t</code> 相同</td></tr><tr><td><code>wchar_t</code></td><td>宽字符类型</td><td><code>L&#39;A&#39;</code>，大写L前缀</td><td>由平台决定</td></tr></tbody></table><p><code>char</code> 是字符类型，属于整数类型，它与 <code>signed char</code> 或者 <code>unsigned char</code> 之一的值表示相同，但是从语言上 <code>char</code> 类型是一个独立的类型，与 <code>signed char</code> 和 <code>unsigned char</code> 均不同。</p><p><code>char8_t</code> 是 UTF-8 字符类型，属于整数类型。它和 <code>unsigned char</code> 有相同的大小和符号性、大小和对齐，但它是和 <code>unsigned char</code> 不同的类型。</p><p><code>char16_t</code> 是 UTF-16 字符类型，属于整数类型。它的大小足够表示一个 UTF-16 编码单元。它和 <code>std::uint_least16_t</code> 有相同的大小和符号性、大小和对齐，但它是和 <code>std::uint_least16_t</code> 不同的类型（见后文）。</p><p><code>char32_t</code> 是 UTF-32 字符类型，属于整数类型。它的大小足够表示一个 UTF-32 编码单元。它和 <code>std::uint_least32_t</code> 有相同的大小和符号性、大小和对齐，但它是和 <code>std::uint_least32_t</code> 不同的类型（见后文）。</p><p><code>wchar_t</code> 是宽字符类型，属于整数类型，它的大小由平台决定，通常是2字节或者4字节。</p><p>在上面列出的类型中，<code>signed char</code>、<code>short</code>、<code>int</code>、<code>long int</code>、<code>long long int</code>称为<strong>基础有符号整数类型</strong>；<code>unsigned char</code>、<code>unsigned short</code>、<code>unsigned int</code>、<code>unsigned long int</code>、<code>unsigned long long int</code>称为<strong>基础无符号整数类型</strong>；<code>char</code>、<code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code>称为<strong>字符类型</strong>。基础有符号整数类型和基础无符号整数类型合起来称为<strong>基础整数类型</strong>。</p><p>除了上述的整数类型之外，C++ 还提供了一些特殊的整数类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型大小</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔类型</td><td><code>true</code>、<code>false</code></td><td>实现定义</td></tr><tr><td><code>std::size_t</code></td><td>表示对象的大小的无符号整数类型</td><td><code>123uz</code>，后缀<code>uz</code>，不区分大小写</td><td>实现定义</td></tr><tr><td></td><td>有符号形式的 <code>std::size_t</code></td><td><code>123z</code>，后缀<code>z</code>，不区分大小写</td><td>实现定义</td></tr><tr><td><code>std::ptrdiff_t</code></td><td>有符号整数类型，用于指针差值</td><td></td><td>实现定义</td></tr></tbody></table><p><code>bool</code> 是布尔类型，属于整数类型，它只有两个值 <code>true</code> 和 <code>false</code>。<code>bool</code> 类型的大小 C++ 没有规定，但是通常为1字节。</p><p><code>std::size_t</code> 是用于表示对象的大小的无符号整数类型。是 <code>sizeof</code> 和 <code>alignof</code> 运算符的结果类型。<code>std::size_t</code> 的大小由平台决定，且 <code>std::size_t</code> 实现通常是前述整数类型之一的类型别名。</p><p><code>std::ptrdiff_t</code> 是用于表示指针差值的整数类型。它足够容纳两个指针之间的差值。我们会在后面的章节中介绍指针类型。</p><h3 id="一些实现的类型大小" tabindex="-1"><a class="header-anchor" href="#一些实现的类型大小"><span>一些实现的类型大小</span></a></h3><p>下表展示了不同实现的整数类型的位宽。</p><table><thead><tr><th>数据模型</th><th><code>short int</code></th><th><code>int</code></th><th><code>long int</code></th><th><code>long long int</code></th><th><code>std::size_t</code></th><th>典型平台</th></tr></thead><tbody><tr><td></td><td>16</td><td>16</td><td>32</td><td>64</td><td></td><td>C++ 标准规定的最小位宽</td></tr><tr><td>ILP32</td><td>16</td><td>32</td><td>32</td><td>64</td><td>32</td><td>x86-32</td></tr><tr><td>LLP64</td><td>16</td><td>32</td><td>32</td><td>64</td><td>64</td><td>Windows（包括 x86-64，IA-64，ARM64）</td></tr><tr><td>LP64</td><td>16</td><td>32</td><td>64</td><td>64</td><td>64</td><td>Unix和多数类Unix系统，如Linux，macOS，Solaris</td></tr><tr><td>ILP64</td><td>16</td><td>64</td><td>64</td><td>64</td><td>64</td><td>一些科学计算领域的平台，如Cray</td></tr><tr><td>SILP64</td><td>64</td><td>64</td><td>64</td><td>64</td><td>64</td><td>Classic UNICOS</td></tr><tr><td></td><td>16</td><td>16</td><td>32</td><td>64</td><td>16 (是 <code>unsigned int</code> 的别名)</td><td>嵌入式系统，如AVR</td></tr><tr><td></td><td>8</td><td>8</td><td>16</td><td>32</td><td>16 (是 <code>long unsigned int</code>的别名)</td><td>嵌入式系统，如AVR（int8模式）</td></tr></tbody></table><h3 id="扩展整数类型" tabindex="-1"><a class="header-anchor" href="#扩展整数类型"><span>扩展整数类型</span></a></h3><p>除了上述的整数类型之外，根据实现，C++ 也会提供另外的扩展整数类型，其中典型的就是定宽整数类型。这些类型有：</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><code>std::int8_t</code></td><td>有符号8位整数</td><td>可选提供</td></tr><tr><td><code>std::int16_t</code></td><td>有符号16位整数</td><td>可选提供</td></tr><tr><td><code>std::int32_t</code></td><td>有符号32位整数</td><td>可选提供</td></tr><tr><td><code>std::int64_t</code></td><td>有符号64位整数</td><td>可选提供</td></tr><tr><td><code>std::uint8_t</code></td><td>无符号8位整数</td><td>可选提供</td></tr><tr><td><code>std::uint16_t</code></td><td>无符号16位整数</td><td>可选提供</td></tr><tr><td><code>std::uint32_t</code></td><td>无符号32位整数</td><td>可选提供</td></tr><tr><td><code>std::uint64_t</code></td><td>无符号64位整数</td><td>可选提供</td></tr><tr><td><code>std::int_fast8_t</code></td><td>至少8位的最快整数类型</td><td></td></tr><tr><td><code>std::int_fast16_t</code></td><td>至少16位的最快整数类型</td><td></td></tr><tr><td><code>std::int_fast32_t</code></td><td>至少32位的最快整数类型</td><td></td></tr><tr><td><code>std::int_fast64_t</code></td><td>至少64位的最快整数类型</td><td></td></tr><tr><td><code>std::uint_fast8_t</code></td><td>至少8位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::uint_fast16_t</code></td><td>至少16位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::uint_fast32_t</code></td><td>至少32位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::uint_fast64_t</code></td><td>至少64位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::int_least8_t</code></td><td>至少8位的最小整数类型</td><td></td></tr><tr><td><code>std::int_least16_t</code></td><td>至少16位的最小整数类型</td><td></td></tr><tr><td><code>std::int_least32_t</code></td><td>至少32位的最小整数类型</td><td></td></tr><tr><td><code>std::int_least64_t</code></td><td>至少64位的最小整数类型</td><td></td></tr><tr><td><code>std::uint_least8_t</code></td><td>至少8位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::uint_least16_t</code></td><td>至少16位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::uint_least32_t</code></td><td>至少32位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::uint_least64_t</code></td><td>至少64位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::intmax_t</code></td><td>最大位宽有符号整数类型</td><td></td></tr><tr><td><code>std::uintmax_t</code></td><td>最大位宽无符号整数类型</td><td></td></tr><tr><td><code>std::intptr_t</code></td><td>整数类型，用于指针</td><td></td></tr><tr><td><code>std::uintptr_t</code></td><td>无符号整数类型，用于指针</td><td></td></tr></tbody></table><p>这些类型的名字不是关键字，因此以 <code>std::</code> 作为前缀。</p><p><code>std::int8_t</code>、<code>std::int16_t</code>等定宽整数类型的位宽是确定的，它仅当实现直接提供这样尺寸的整数类型时才会存在。如果前面提到的如 <code>int</code> <code>long int</code> 这样的类型本身就满足定宽的要求，那么这些定宽类型可以是对应的类型的别名。例如，如果某个实现中 <code>int</code> 恰好是32位的，那么允许 <code>using int32_t = int;</code> 来声明 <code>std::int32_t</code> 类型。</p><p><code>std::int_fast8_t</code>、<code>std::int_fast16_t</code>等最快整数类型是指在当前平台上最快的整数类型，它们的位宽是不确定的，但是至少是指定的位宽。由于平台上最快的整数类型是 <code>int</code>, 因此尺寸小于 <code>int</code> 的最快整数类型往往是 <code>int</code>。</p><p>实现可以提供 <code>N</code> 不在上述之列的 <code>std::intN_t</code>，<code>std::int_fastN_t</code> 和 <code>std::int_leastN_t</code> 等类型，但也必须满足 <code>std::intN_t</code> 的位宽是 <code>N</code>，<code>std::int_fastN_t</code> 和 <code>std::int_leastN_t</code> 的位宽至少是 <code>N</code>。</p><p><code>std::intptr_t</code> 和 <code>std::uintptr_t</code> 是用于指针的整数类型。<code>std::intptr_t</code> 是有符号整数类型，<code>std::uintptr_t</code> 是无符号整数类型。它们足够容纳对象指针类型的位宽。</p><h3 id="整数类型的运算" tabindex="-1"><a class="header-anchor" href="#整数类型的运算"><span>整数类型的运算</span></a></h3><p>整数类型的运算基本与<!---->章节中介绍的一致，除了由于位宽和 <code>int</code> 不同，结果的范围有所不同。</p><p>在前面<!---->的章节中提到过，如果 <code>int</code> 类型表达式的计算结果超出了 <code>int</code> 类型的范围，那么结果是未定义的。这种性质对其他有符号整数类型也是适用的。</p><p>但是，对于无符号整数类型，例如 <code>unsigned int</code>，标准保证运算是模运算。即，如果结果超出了类型的范围，那么结果会被取模到类型的范围内。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假定 unsigned int 是 32 位，因此 4294967295 是此类型的最大值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4294967295</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保证 a + b 的结果，以及 c 的值是 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="整数提升" tabindex="-1"><a class="header-anchor" href="#整数提升"><span>整数提升</span></a></h3><p>之前的章节中介绍过，在计算 <!----> 时，如果操作数是 <code>bool</code> 或者 <code>char</code> 时，会转换为 <code>int</code> 类型。这种转换称为整数提升。</p><p>这个规则具体而言是：</p><ul><li>如果操作数是除了 <code>bool</code>、<code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code> 之外的、比 <code>int</code> 更小的整数类型，如果 <code>int</code> 能容纳操作数的值，那么将操作数转换为 <code>int</code> 类型。否则，将操作数转换为 <code>unsigned int</code> 类型。（例如，<code>char</code> 和 <code>short</code> 类型会被提升为 <code>int</code> 类型）</li><li>如果操作数是 <code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code> 类型之一，按照下面的顺序：<code>int</code>、<code>unsigned int</code>、<code>long int</code>、<code>unsigned long int</code>，<code>long long int</code>、<code>unsigned long long int</code>。选择第一个值范围能够容纳的。将操作数转换为这个类型。</li><li>如果操作数是 <code>bool</code> 类型，那么将操作数转换到 <code>int</code> 类型，<code>false</code> 转换为 <code>0</code>，<code>true</code> 转换为 <code>1</code>。</li></ul><h3 id="整数转换" tabindex="-1"><a class="header-anchor" href="#整数转换"><span>整数转换</span></a></h3><p>在<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>之外，整数还有一些转换情况。</p><ul><li>如果目标类型是 <code>bool</code> 类型，那么如果操作数是 <code>0</code>，那么结果是 <code>false</code>，否则结果是 <code>true</code>。</li><li>如果源类型是 <code>bool</code> 类型，那么如果操作数是 <code>false</code>，那么结果是 <code>0</code>，如果操作数是 <code>true</code> 结果是 <code>1</code>。</li></ul><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b 的值是 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c 的值是 true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是 1，42 转换为 true，然后 true 转换为 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述情况之外，转换结果的值是，在目标类型范围内，源值对2^N取模的唯一值，其中 N 是目标类型的位宽。读者可以将这个规则理解为，在数学意义上的如下计算：</p><p><code>Result = Mod(Source - TargetMin, 2^N) + TargetMin</code></p><p>其中，<code>Mod</code>是取余（模运算），<code>Source</code>是源值，<code>TargetMin</code> 是目标类型的最小值，<code>N</code> 是目标类型的位宽。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从 int 类型的 256 转换到 unsigned char</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 unsigned char 位宽为8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 256 对 256 取模是 0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a 的值是 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从 int 类型的 -1 转换到 unsigned long long</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 unsigned long long 位宽为64</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -1 对 2^64 取模是 18446744073709551615</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b 的值是 18446744073709551615</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从 int 类型的 144 转换到 signed char</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 signed char 位宽为8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 144 对 256 取模，signed char 的范围是 -128 到 127，结果是 -112</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// c 的值是 -112</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">signed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 144</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="浮点类型" tabindex="-1"><a class="header-anchor" href="#浮点类型"><span>浮点类型</span></a></h2><p>在<!---->一节中，已经简要概述了浮点类型的字面量，这里我们详细介绍浮点类型。</p><h3 id="标准浮点类型" tabindex="-1"><a class="header-anchor" href="#标准浮点类型"><span>标准浮点类型</span></a></h3><p>C++ 中默认提供的浮点类型包括：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型位宽</th></tr></thead><tbody><tr><td><code>float</code></td><td>单精度浮点数，IEEE-754 binary32 浮点数</td><td><code>1.0f</code>，后缀<code>f</code></td><td>32</td></tr><tr><td><code>double</code></td><td>双精度浮点数，IEEE-754 binary64 浮点数</td><td><code>1.0</code>，没有后缀</td><td>64</td></tr><tr><td><code>long double</code></td><td>扩展精度浮点数</td><td><code>1.0l</code>，后缀<code>l</code></td><td>实现定义</td></tr></tbody></table><p>这些浮点数的行为基本上由 IEEE-754 标准所规定。其中，<code>float</code> 有 1 个符号位、8 个指数位和 23 个尾数位，<code>double</code> 有 1 个符号位、11 个指数位和 52 个尾数位，<code>long double</code> 的位数是实现定义的，如果实现为 x86 上实现的 IEEE-754 binary64 扩展模式，那么它的位数可能是 1 个符号位、15 个指数位和 64 个尾数位。</p><div class="hint-container info"><p class="hint-container-title">浮点数的表示</p><p>浮点数根据 IEEE-754 有确定的表示形式。例如，<code>3.14f</code> 的值表示是 <code>0 10000000 1001000 11110101 11000011</code>，其中第一位是符号位，接下来的8位是指数，最后的23位是尾数。</p><p>浮点数的表示可以简单地理解成科学计数法的形式，其中指数部分是以 2 为底的指数，尾数部分是二进制小数（二进制 0.1 表示十进制 0.5，二进制 0.11 表示十进制 0.75，二进制 10.101 表示十进制 2.625）。科学记数法中，1e2 和 10e1 是等价的，因此，IEEE-754 规定，尾数部分的二进制小数总会标准化到 <code>1.xxx</code> 的形式；并且由于尾数第一位总是 <code>1</code>，所以省略不存储。指数部分中，IEEE-754 规定，<code>01111111</code> 表示指数为 0，<code>10000000</code> 表示指数为 1，<code>10000001</code> 表示指数为 2，可以理解成一个 0 值与常规不同的 8 位无符号整数。</p><p>因此，我们反推上述的 <code>3.14f</code> 的值表示，它表示的是 + 1.10010001111010111000011 * 2，即 3.1400001049041748046875。读者会发现这是个近似数，毕竟有效位数有限，在进制转换时，经常会有精度损失。</p><p>不过，如果我们考虑 + 1.10010001111010111000010 * 2，也即把最后一位从 1 改成 0，即 3.139999866485595703125，可以发现它和十进制 3.14 的差距比上面的结果更大，也即是说，上面的表示是最接近十进制 3.14 的浮点数。这不是巧合，实现按照规定会将十进制浮点数字面量转换到最接近的 IEEE-754 浮点数。</p><p>有心的读者可能会意识到，假设某个十进制 A 转换到浮点数后，得到的是 IEEE-754 规定的浮点数 B，如果我们再利用输出函数（例如前面提到的<code>std::println</code>）输出 B 会得到什么呢？在现实中，一个浮点数的默认输出常常是其唯一最短形式的十进制小数表示，也即上面的 <code>0 10000000 1001000 11110101 11000011</code> 一定输出为 3.14，而 <code>0 10000000 1001000 11110101 11000010</code> 一定输出为 3.1399999，并且这一转换是可逆的，也即 <code>3.1399999f</code> 一定转换到 <code>0 10000000 1001000 11110101 11000010</code>。浮点数输入输出会计算出到无歧义的最短十进制小数表示，这是 IEEE-754 标准的要求。简单的来说，字面上有多个十进制小数都可以转换到同一个浮点数，但是浮点数转换到十进制小数时，只有一种最短表示，且这一最短表示一定转换成对应的浮点数。</p><!----></div><h3 id="扩展浮点类型" tabindex="-1"><a class="header-anchor" href="#扩展浮点类型"><span>扩展浮点类型</span></a></h3><p>实现可能支持 ISO 60559 规定的扩展浮点类型，这些类型包括：</p><table><thead><tr><th>类型</th><th>ISO 60559 名称</th><th>类型位宽</th><th>指数位宽</th><th>尾数位宽</th></tr></thead><tbody><tr><td><code>std::float16_t</code></td><td>binary16</td><td>16</td><td>5</td><td>10</td></tr><tr><td><code>std::float32_t</code></td><td>binary32</td><td>32</td><td>8</td><td>23</td></tr><tr><td><code>std::float64_t</code></td><td>binary64</td><td>64</td><td>11</td><td>52</td></tr><tr><td><code>std::float128_t</code></td><td>binary128</td><td>128</td><td>15</td><td>112</td></tr><tr><td><code>std::bfloat16_t</code></td><td></td><td>16</td><td>8</td><td>7</td></tr></tbody></table><h3 id="浮点计算" tabindex="-1"><a class="header-anchor" href="#浮点计算"><span>浮点计算</span></a></h3><p>浮点数类型不能进行全部的前面<!---->所介绍的运算。浮点数的计算是按照 IEEE-754 标准进行的，这主要包括：</p><ul><li><!---->和<!---->：将操作数浮点数的值增加1。</li><li><!---->和<!---->：将操作数浮点数的值减少1。</li><li><!---->：表达式的值与操作数相同。</li><li><!---->：将操作数的符号取反。</li><li><!---->：如同数学计算，表达式的值是将操作数的值进行计算。由于浮点数存在精度，因此在计算时可能会有舍入。浮点数不能进行模运算（<code>%</code>）。</li><li><!---->：如同数学比较。不过浮点数有一些特殊值，这在后面进行介绍。三路比较时，浮点数的比较结果是 <code>std::partial_ordering</code> 类型，会出现一个特殊的“无顺序”结果。</li><li><!---->：如同整数的赋值。</li></ul><p>简单的来看，浮点数和整数具有的运算基本相同，但是和位运算相关的部分则不适用于浮点数。</p><h3 id="特殊浮点值" tabindex="-1"><a class="header-anchor" href="#特殊浮点值"><span>特殊浮点值</span></a></h3><p>浮点数有一些特殊的值，它们是：正零(+0)、负零(-0)、正无穷(+∞)、负无穷(-∞)、qNaN，sNaN。</p><p>正零的值表示为 <code>0 00000000 00000000000000000000000</code>，负零的值表示为 <code>1 00000000 00000000000000000000000</code>。</p><p>正无穷的值表示为 <code>0 11111111 00000000000000000000000</code>，负无穷的值表示为 <code>1 11111111 00000000000000000000000</code>。</p><p>NaN是Not a Number，意思是不是一个数，当然这也是一种浮点数，而非“不是数”。qNaN是quiet NaN，sNaN是signaling NaN。qNaN 是静默 NaN，而 sNaN 是信号 NaN。NaN 的值表示为 <code>0 11111111 1xxxxxx xxxxxxxx xxxxxxxx</code>，其中指数部分全为1，尾数部分不全为0（注意全为0时这就是正无穷了）。qNaN 的尾数部分（除了那个必须为1的位）最高位为1，而 sNaN 的对应位为0。sNaN 具有一些实现上的作用，例如：</p><ul><li>把内存填满 sNaN，可以检测内存的初始化情况。</li><li>标记溢出的情况</li><li>标记计算结果可能具有更高精度</li><li>标记复数</li></ul><p>这些特殊值在计算和比较的时候具有特殊规则（下面使用 ±0 表示 +0 或 -0，±∞ 表示 +∞ 或 -∞）。</p><p>对于加性表达式和乘性表达式，有以下规则：</p><ul><li>任意浮点数（包括NaN）和 NaN 进行计算，结果是 NaN</li><li>非特殊浮点数除以 ±0 结果是 ±∞（符号与正常除法相同）</li><li>非特殊浮点数计算的结果如果溢出了浮点数范围，则上溢出的结果是 +∞，下溢出的结果是 -∞</li><li>±0 / ±0 结果是 NaN</li><li>±∞ / ±∞ 结果是 NaN</li><li>±0 * ±∞ 结果是 NaN</li><li>+∞ + -∞ 和 +∞ + -∞ 结果是 NaN</li><li>+∞ + +∞ 结果是 +∞，-∞ + -∞ 结果是 -∞</li><li>+∞ - +∞ 结果是 NaN，-∞ - -∞ 结果是 NaN</li></ul><p>对于关系表达式，有以下规则：</p><ul><li>+0 和 -0 相等</li><li>+∞ 和 +∞ 相等， -∞ 和 -∞ 相等</li><li>+∞ 大于任意非特殊浮点数，-∞ 小于任意非特殊浮点数</li><li>任意浮点数（包括NaN）和 NaN 进行任意比较，结果是 <code>false</code>。 <ul><li>对于三路比较（<code>&lt;=&gt;</code>），得到的结果是 <code>std::partial_ordering::unordered</code>。</li></ul></li></ul><h3 id="浮点舍入" tabindex="-1"><a class="header-anchor" href="#浮点舍入"><span>浮点舍入</span></a></h3><p>浮点数的计算可能会有舍入，这是因为浮点数的表示是有限的，而实数是无限的。IEEE-754 标准规定了浮点数的计算规则，每一次表达式求值都可能会按照这一规则发生舍入。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，<code>1.01 * 3</code> 得到的结果并不是准确的 <code>3.03</code>，而是一个接近于 <code>3.0300000000000002</code> 的值。因此，<code>a</code> 的值可能并不是 <code>0</code>，而是一个很小的值（大约 <code>4.440892098500626e-16</code>）。</p><div class="hint-container info"><p class="hint-container-title">精度保证</p><p>C++ 本身并没有对浮点精度做任何保证。在上面的例子中，<code>a</code> 的值也可能被初始化为 <code>0</code>。C++ 允许编译器对浮点数计算做出非常激进的优化，将字面量加减乘除的计算过程认为是无限精度，并只在最终结果上做舍入。此外，现实的处理器存在融合乘法和加法的指令，这种指令可以在计算先乘后加的表达式时保证结果，不会由于多余的一次舍入产生精度问题。因此，上面的例子中，<code>a</code> 的值可能是 <code>0</code>，也可能是一个很小的值，这取决于编译器的优化策略和目标平台的浮点数计算能力。</p></div><p>在处理浮点数时，凡是进行了会损失精度的计算（包括加减乘除等），都可能会有类似的情况，因此，在进行浮点数比较时，应该使用一个误差范围，而不是直接比较两个浮点数的值，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import std;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> double_equal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 误差范围为 1e-9</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">e-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">e-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a = 0 results {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">double_equal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面程序的输出应当是 <code>a = 0 results true</code>。</p><h3 id="浮点转换" tabindex="-1"><a class="header-anchor" href="#浮点转换"><span>浮点转换</span></a></h3><p>在前面提到的，浮点数的计算中，如果操作数的类型不同，那么会按照以下规则进行转换：</p><ul><li>如果另一个操作数不是浮点数，那么将那个非浮点数的操作数转换为相同的浮点数类型。 <ul><li>对于符合 IEEE-754 标准的浮点数，这一转换会转换到最近的浮点数。</li></ul></li><li>如果另一个操作数是浮点数，但是类型不同，那么将较小的浮点数转换为较大的浮点数。 <ul><li>例如，<code>float</code> 和 <code>double</code> 参与计算时，<code>float</code> 会转换为 <code>double</code>。</li></ul></li></ul><p>此外，使用浮点类型可以初始化整数类型，这时候浮点数会被截断为整数，即舍弃小数部分，而不是四舍五入。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b 的值是 3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> conversion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> conversion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c 的值是 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果截断之后，浮点数的值超出了整数类型的范围，这时行为是<!---->。</p><p>使用整数类型也可以初始化浮点数类型，这时候整数会被转换为浮点数，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // d 的值是 42.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，如果转换不能保证精度，那么实现可以选择向上或者向下舍入；对于 IEEE-754 标准的浮点数，这种转换会转换到最近的浮点数。</p><p>如果转换之后，整数的值超出了浮点数类型的范围，这时行为是<!---->。</p><h2 id="一般算术转换" tabindex="-1"><a class="header-anchor" href="#一般算术转换"><span>一般算术转换</span></a></h2><p>在目前介绍到的内容中，出现了多种形式的转换，包括<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>、<a href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2">整数转换</a>、<a href="#%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2">浮点转换</a>。</p><p>现在，我们来综合地介绍一下。在需要操作数是算术类型的表达式中，会进行一些形式相似的转换，这种转换称为<strong>一般算术转换</strong>。</p><p>对于算术类型，下列的表达式会先对操作数进行一般算术转换：</p><ul><li><!----></li><li><!----></li><li><!----></li><li><!----></li><li><!----></li><li><!----></li></ul><h3 id="转换等级" tabindex="-1"><a class="header-anchor" href="#转换等级"><span>转换等级</span></a></h3><p>在一般算术转换中，整数转换遵循如下的整数转换等级：</p><ul><li>有符号整数类型的等级高于任意位宽更小的有符号整数类型（例如，<code>std::int32_t</code> 高于 <code>std::int16_t</code>）</li><li>下列类型的等级依次递减 <ul><li><code>long long int</code></li><li><code>long int</code></li><li><code>int</code></li><li><code>short int</code></li><li><code>signed char</code></li></ul></li><li>任一无符号整数类型的等级，等于对应的有符号整数类型的等级（例如，<code>std::uint32_t</code> 的等级等于 <code>std::int32_t</code> 的等级）</li><li><code>bool</code> 类型的等级低于任何标准整数类型</li><li><code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code> 的等级等于其基础类型的等级（例如，<code>char8_t</code> 的等级等于 <code>unsigned char</code> 的等级，<code>char16_t</code> 的等级等于 <code>std::uint_least16_t</code> 的等级）</li><li>扩展整数类型的等级由实现定义，但仍遵循上述规则（例如，如果 <code>std::int_fast16_t</code> 的位宽高于 <code>short int</code>，其等级也一定高于 <code>short int</code>）</li></ul><p>在一般算术转换中，浮点数转换遵循如下的浮点转换等级：</p><ul><li>如果某个浮点数类型的所有值是是另一个类型的所有值的子集，那么这个浮点数类型的等级低于另一个浮点数类型的等级 <ul><li><code>long double</code> 的等级高于 <code>double</code> 的等级，<code>double</code> 的等级高于 <code>float</code> 的等级</li></ul></li><li>具有相同值集合的扩展浮点数类型的等级相等 <ul><li>与基础整数类型值集合相同的扩展浮点数类型的等级相等</li></ul></li></ul><h3 id="一般算术转换-1" tabindex="-1"><a class="header-anchor" href="#一般算术转换-1"><span>一般算术转换</span></a></h3><p>一般算术转换的规则如下：</p><ul><li>如果任一操作数是浮点数类型： <ul><li>如果两个操作数的类型相同，不需要转换</li><li>否则，如果其中一个操作数的类型是非浮点数类型，将这个操作数转换到与另一个操作数相同的浮点数类型</li><li>否则，如果两个操作数的类型不同，将较小的浮点数转换为两个操作数中，转换等级较高的浮点数类型</li></ul></li><li>否则，每个操作数会转换到一个公共类型。此时，每个操作数都会发生<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。 <ul><li>如果提升后两个操作数的类型相同，那么不需要转换</li><li>否则，如果提升后两个操作数都是有符号整数类型，或者都是无符号整数类型，那么将较小的操作数转换为较大的操作数</li><li>否则，假设提升后操作数类型中，无符号的类型为U，有符号的类型为S <ul><li>如果U的转换等级高于S，那么将操作数都转换为U</li><li>否则，如果S的转换等级高于U，那么将操作数都转换为S</li><li>否则，将操作数都转换为S的无符号版本</li></ul></li></ul></li></ul><p>上面这样一条一条的规则显然只适合于考试和编译器开发者，如果需要日常开发中天天想着这个规则，显然是不现实的。为了方便理解，这里对这个规则做出一个简略的总结：</p><ol><li>将整数变成浮点</li><li>将小于<code>int</code>的类型变成<code>int</code></li><li>将扩展类型变成标准类型</li><li>将较小的类型变成较大的类型</li><li>将一样大的有符号类型变成无符号类型。</li></ol><p>举例而言：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 没有操作数是浮点数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 整数提升后，类型分别是 `int` 和 `unsigned int`，两者转换等级仍然相同</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 转换为 `int` 的无符号版本，结果是 `unsigned int` 类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 有一个操作数是浮点数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 `int` 转换为 `float`，结果是 `float` 类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的转换规则仍然是一定程度的简化，涉及值类别转换和枚举类型的部分，会在后续章节中介绍。</p><div class="hint-container info"><p class="hint-container-title">为什么？</p><p>一般算术转换的规则是对现实的概括和妥协。</p><p>在常见的平台上，浮点和整数是通过两套不同的电路处理的，这一现实在 C++ 语言上体现为浮点和整数仿佛是两个冤家，在一个浮点数加入了聚会之后，整个聚会就被迫变成了浮点数的聚会，这时候那些位运算就被请出了门。如果非要让浮点数加入整数的聚会，我们就不得不费劲地把浮点数塞进整数的衣服里。</p><p>这里这种“处理整数的电路”，它提供的很多功能要求数据至少有 <code>int</code> 的尺寸，并且参与处理的两个数据也要求大小相同。正因如此，一般算术转换中会将小于 <code>int</code> 的整数类型转换为 <code>int</code>，并且必须找到一个公共的类型来进行运算。</p><p>基础算术类型是对平台这种特性的一种抽象，它将硬件支持最佳的几种数据表示抽象为 <code>int</code>、<code>long int</code> 这些基础类型。然后再提供扩展类型，以适应更多的需求。</p><p>事实上，这种先抽象成基础类型，再抽象成扩展类型的二次抽象是一种过于复杂的历史遗留。程序员仍然需要浪费心智查看硬件手册，以理解 <code>int</code> 和 <code>char</code> 究竟是什么东西。已经进行了尝试的读者也会发现，几乎所有情况下，<code>std::int32_t</code> 就是 <code>int</code>，<code>std::int64_t</code> 就是 <code>long long int</code>，这层抽象在实际中几乎没有产生任何价值。于是，更现代的设计直接将扩展类型作为基础类型，具体如何选择表示和指令让编译器来分析。笔者也推荐读者直接使用扩展类型，而不要费神纠结基础类型的性质。</p></div></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/dynilath/moder-cpp-primer/edit/main/src/zh/03-types/arithmetic-types.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: dynilath@qq.com">dynilath</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/modern-cpp-primer/zh/03-types/type-intro.html" aria-label="3.1 类型概述"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><FontIcon></FontIcon>3.1 类型概述</div></a><a class="route-link auto-link next" href="/modern-cpp-primer/zh/03-types/cv-qualifiers.html" aria-label="3.3 const 与 volatile 限定符"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">3.3 const 与 volatile 限定符<FontIcon></FontIcon></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/modern-cpp-primer/assets/app-DNTRvR-x.js" defer></script>
  </body>
</html>
