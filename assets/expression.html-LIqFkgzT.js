import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o as p,c as k,a as s,d as h,e as l,w as c,b as i}from"./app-DNTRvR-x.js";const r={},g=i(`<p>表达式是组成 C++ 程序的基本元素之一。<strong>表达式</strong>表示一个计算过程，可以用来计算一个值，以及产生其他影响程序状态的副作用。</p><p>在编译器处理表达式的时候，换行符如同空格一样，当做空白字符处理。因此，换行符不会影响表达式的语义。</p><h2 id="操作数" tabindex="-1"><a class="header-anchor" href="#操作数"><span>操作数</span></a></h2><p>表达式常常由数个表达式和一个运算符组合而成。为了方便理解，我们将这样由运算符和表达式组成的表达式，其中的表达式称为<strong>操作数</strong>。</p><p>对于操作数只有一个的表达式，有如下的形式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // \`+\` 是运算符，\`a\` 是操作数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于运算符位于两个操作数之间的表达式，有如下的形式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // \`+\` 是运算符，\`a\` 和 \`b\` 是操作数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，称运算符左边的操作数（上面的 <code>a</code>）为<strong>左操作数</strong>，右边的操作数（上面的 <code>b</code>）为<strong>右操作数</strong>。</p><h2 id="未定义行为" tabindex="-1"><a class="header-anchor" href="#未定义行为"><span>未定义行为</span></a></h2><p>在 C++ 中，有一些编写符合语法，但并不“正确”的程序的行为，称为<strong>未定义行为</strong>。标准没有规定发生未定义行为的程序应该如何运行——这样的行为可能会导致程序崩溃、产生错误的结果、或者产生其他不可预测的行为。</p><p>未定义行为常常是一种在实现和程序编写之间的妥协，当然也有一部分是历史原因遗留的错误设计。</p><div class="hint-container info"><p class="hint-container-title">一种奇妙的模因</p><p>在程序员圈子常常会嘲笑 C++ 的未定义行为。例如，“在作业本里写下1/0，引发了未定义行为从而骗过了老师的检查”，“输入1/0，然后我的程序把我的系统盘格式化了”。</p><p>诚然，未定义行为对于程序设计无疑会带来不少的心智负担，但现实世界里的程序天然运行在一个充满无法预测行为的环境中，与其设计一种“不存在未定义行为”的编程语言，不如想办法让程序员更好地理解未定义行为，这也正是笔者认为 C++ 这种古董语言的最大问题。</p></div><h2 id="基本表达式" tabindex="-1"><a class="header-anchor" href="#基本表达式"><span>基本表达式</span></a></h2><p>基本表达式是表达式的最基本组成部分，通常而言基本表达式是一个整体。基本表达式包括：</p><p>这一节作为入门，只介绍一部分的基本表达式。</p><p><strong>字面量</strong> 组成了一个基本表达式，这个基本表达式的值就是字面量的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 整数字面量 42 组成的基本表达式，值为整数值 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>标识符</strong> 可以是一个基本表达式，它的值是标识符所代表的对象的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 标识符a组成的基本表达式，值为标识符 a 所代表的对象的值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>括号包围的表达式</strong> 也是一个基本表达式，它的值是括号内表达式的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 括号内的整数字面量 42 组成的基本表达式，值为整数值 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 括号内的表达式 a + b 组成的基本表达式，值为 a + b 的值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这个例子里<code>(a + b)</code>是一个基本表达式，但是它里面的表达式却不是基本表达式。那么如何理解基本表达式是一个整体呢？</p><p>不妨考虑这样的结构：<code>(a + b) * c</code>，这个表达式的值是 <code>(a + b)</code> 和 <code>c</code> 进行 <code>*</code> 运算的结果，而不是 <code>a + (b * c)</code> 。这就是基本表达式是一个整体的含义，基本表达式的值只用考虑基本表达式本身，而不用考虑其他组合。</p><div class="hint-container info"><p class="hint-container-title">结合性、优先级与表达式组成的关系</p><p>读者可能会觉得，这不就是数学运算的优先级吗？</p><p>是的，仅考虑算术运算的话，括号的作用就像数学中一样。但是，C++ 中的表达式不仅仅是算术运算，还有很多其他的表达式，有的看起来完全不像个运算；表达式还有一些数学算式所不具有的性质，这都需要对表达式有一个更直观的理解。</p><p>因此，这里采用了表达式结构的形式来解释表达式，而不是数学运算优先级的形式。</p></div><h2 id="后缀表达式" tabindex="-1"><a class="header-anchor" href="#后缀表达式"><span>后缀表达式</span></a></h2><p>这里暂时只介绍下列的三种后缀表达式：</p><ul><li>① <code>基本表达式</code></li><li>② <code>后缀表达式 ++</code></li><li>③ <code>后缀表达式 --</code></li></ul><p>其中 <code>++</code> 表示自增运算符，<code>--</code> 表示自减运算符。由于这是后缀表达式，所以准确的说，这里的 <code>++</code> 是后缀自增运算符，<code>--</code> 是后缀自减运算符。</p><h3 id="后缀自增运算符" tabindex="-1"><a class="header-anchor" href="#后缀自增运算符"><span>后缀自增运算符</span></a></h3><p>后缀自增运算符的作用是，将操作数表示的对象加一，表达式的值是这个对象加一之前的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 a++ 的值是 10，a 的值变为 11</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自增运算。</p><h3 id="后缀自减运算符" tabindex="-1"><a class="header-anchor" href="#后缀自减运算符"><span>后缀自减运算符</span></a></h3><p>后缀自减运算符的作用是，将操作数表示的对象减一，表达式的值是这个对象减一之前的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 a-- 的值是 10，a 的值变为 9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自减运算。</p><h2 id="一元表达式" tabindex="-1"><a class="header-anchor" href="#一元表达式"><span>一元表达式</span></a></h2><p>一元表达式有很多种，这里暂时只介绍其中两种与算术相关的表达式：正运算符和负运算符表达式。其形式为：</p><ul><li><code>+ 一元表达式</code></li><li><code>- 一元表达式</code></li><li><code>~ 一元表达式</code></li><li><code>! 一元表达式</code></li><li><code>++ 一元表达式</code></li><li><code>-- 一元表达式</code></li><li><code>后缀表达式</code></li></ul><p>其中 <code>+</code> 表示正运算符，<code>-</code> 表示负运算符，<code>~</code> 表示按位取反，<code>!</code> 表示逻辑非，<code>++</code> 表示前缀自增运算符，<code>--</code> 表示前缀自减运算符。</p><div class="hint-container info"><p class="hint-container-title">更多一元表达式</p><p>技术性地说，一元表达式形式应当是 <code>+ 转换表达式</code>、<code>- 转换表达式</code>、<code>后缀表达式</code>等。<code>后缀表达式</code> 又由<code>函数调用</code>、<code>数组访问</code>、<code>基本表达式</code>等组成。</p><p>这里为了方便理解，对一元表达式的形式做出了简化，只介绍了一元表达式的一部分。</p></div><h3 id="正运算符" tabindex="-1"><a class="header-anchor" href="#正运算符"><span>正运算符</span></a></h3><p>目前我们只考虑 <code>int</code>、<code>bool</code>、<code>char</code> 这三种基本类型的运算。</p><p>对于 <code>int</code>，正运算符的作用是得到操作数的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意，<code>+a</code>这个表达式虽然值和 <code>a</code> 一样，但是 <code>+a</code> 不同与 <code>a</code>，不再指代 <code>a</code> 所代表的对象，而是另一个和 <code>a</code> 相同的值。</p><h3 id="整数提升" tabindex="-1"><a class="header-anchor" href="#整数提升"><span>整数提升</span></a></h3><p>对于 <code>bool</code> 和 <code>char</code> 类型，正运算符会将其转换为 <code>int</code> 类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 97</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个转换被称为整数提升，类型大小比 <code>int</code> 小的整数类型在正运算符、负运算符的表达式中会被提升为 <code>int</code> 类型。</p><p>后面会介绍到其他的、会发生整数提升的表达式。它们遵循相同的规则，即将类型大小比 <code>int</code> 小的整数类型提升为 <code>int</code> 类型，然后进行计算。</p><h3 id="负运算符" tabindex="-1"><a class="header-anchor" href="#负运算符"><span>负运算符</span></a></h3><p>负运算符的作用是得到操作数的相反数。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>负运算符的作用和正运算符类似，同样会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -97</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，<code>-a</code> 表达式的值和 <code>a</code> 的值相反，但是类似与 <code>+a</code> 并不指代 <code>a</code> 这个对象，<code>-a</code> 并不会改变 <code>a</code> 的值。</p><h3 id="按位取反" tabindex="-1"><a class="header-anchor" href="#按位取反"><span>按位取反</span></a></h3><p>按位取反运算符的作用是对操作数的每一位取反。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -43</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>假设 <code>int</code> 类型是32位的，<code>42</code> 的二进制表示是<code>0000 0000 0000 0000 0000 0000 0010 1010</code>，取反后的二进制表示是<code>1111 1111 1111 1111 1111 1111 1101 0101</code>，转换为十进制就是<code>-43</code>。</p><p>类似于正运算符和负运算符，按位取反运算符也会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -98</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="逻辑非" tabindex="-1"><a class="header-anchor" href="#逻辑非"><span>逻辑非</span></a></h3><p>逻辑非运算符的作用是对操作数取逻辑非，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>逻辑非期待一个 <code>bool</code> 类型的值进行运算，所以这里 <code>42</code> 被转换为 <code>true</code>，然后取逻辑非，结果是 <code>false</code>。</p><h3 id="前缀自增运算符" tabindex="-1"><a class="header-anchor" href="#前缀自增运算符"><span>前缀自增运算符</span></a></h3><p>前缀自增运算符的作用是将操作数表示的对象加一，表达式的值是这个对象加一之后的值、且表示这个对象。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 ++a 的值是 11，a 的值变为 11</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自增运算。</p><h3 id="前缀自减运算符" tabindex="-1"><a class="header-anchor" href="#前缀自减运算符"><span>前缀自减运算符</span></a></h3><p>前缀自减运算符的作用是将操作数表示的对象减一，表达式的值是这个对象减一之后的值、且表示这个对象。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 --a 的值是 9，a 的值变为 9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>bool</code> 类型不能进行自减运算。</p><h2 id="加性表达式和乘性表达式" tabindex="-1"><a class="header-anchor" href="#加性表达式和乘性表达式"><span>加性表达式和乘性表达式</span></a></h2><p>加性表达式和乘性表达式组成了 C++ 中，算术表达式的主要形式。</p><h3 id="乘性表达式" tabindex="-1"><a class="header-anchor" href="#乘性表达式"><span>乘性表达式</span></a></h3><p>乘性表达式的形式是</p><ul><li>①<code>乘性表达式 * 一元表达式</code></li><li>②<code>乘性表达式 / 一元表达式</code></li><li>③<code>乘性表达式 % 一元表达式</code></li><li>④<code>一元表达式</code></li></ul><p>根据中间的标点符号类型，乘性表达式的计算不同。<code>*</code>表示乘法，<code>/</code> 表示除法，<code>%</code> 表示取余（模运算）。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的例子里，<code>a</code> 是一个基本表达式，然后以上文④的形式单独组成了一个乘性表达式。<code>(b * c)</code> 也是一个基本表达式，然后 <code>a * (b * c)</code> 以上文①的形式组成了一个乘性表达式。</p><div class="hint-container info"><p class="hint-container-title">乘性表达式的形式</p><p>技术性地说，乘性表达式的形式中的①是 <code>乘性表达式 * 成员指针表达式</code>，②是 <code>乘性表达式 / 成员指针表达式</code>，以此类推。</p><p>从<code>成员指针表达式</code> 到 <code>一元表达式</code> 中间还有一层 <code>转换表达式</code>。</p><p>为了减少引入过多概念导致理解困难，这里简化了乘性表达式的形式。</p></div><h3 id="加性表达式" tabindex="-1"><a class="header-anchor" href="#加性表达式"><span>加性表达式</span></a></h3><p>加性表达式的形式和乘性表达式很类似。加性表达式的形式是</p><ul><li>①<code>加性表达式 + 乘性表达式</code></li><li>②<code>加性表达式 - 乘性表达式</code></li><li>③<code>乘性表达式</code></li></ul><p>根据中间的标点符号类型，加性表达式的计算不同。<code>+</code>表示加法，<code>-</code> 表示减法。</p><p>这时，我们已经能够组合出基本的四则运算了，例如</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>利用一下上面的知识，我们可以对这个表达式做出如下的分析：</p><ul><li><code>a</code>、<code>b</code>、<code>c</code> 都是基本表达式，其值分别是 <code>a</code>、<code>b</code>、<code>c</code> 所代表的对象的值。</li><li><code>b * c</code> 是一个乘性表达式，其值是 <code>b</code> 和 <code>c</code> 的乘法运算的结果。</li><li><code>a + b * c</code> 是一个加性表达式，其值是 <code>a</code> 和 <code>b * c</code> 的加法运算的结果。</li></ul><p>可以画出一个这样的图示来理解</p>`,94),o=i(`<p>加性表达式的形式里面并不直接包含一元表达式，所以这里<code>a + b * c</code>的分析结果是唯一的：只能先计算 <code>b * c</code>，然后再计算 <code>a + b * c</code>。否则，就会出现<code>加性表达式 * 乘性表达式</code>的形式，这样无论是加性表达式还是乘性表达式都是不符合规定的。</p><h3 id="整数的加减乘除与取余计算" tabindex="-1"><a class="header-anchor" href="#整数的加减乘除与取余计算"><span>整数的加减乘除与取余计算</span></a></h3><p>在一般的情况下，C++ 中整数的加减乘除和数学上的整数运算是一致的。例如：</p><ul><li><code>42 + 24</code>的值是<code>66</code></li><li><code>42 - 24</code>的值是<code>18</code></li><li><code>42 * 24</code>的值是<code>1008</code></li><li><code>42 / 24</code>的值是<code>1</code></li><li><code>42 % 24</code>的值是<code>18</code>。</li></ul><div class="hint-container info"><p class="hint-container-title">整数除法</p><p>读者可能已经忘记了整数除法的规则，这里简单复习一下。</p><p>整数除法的结果是整数商，还记得“7除以2得3余1”这样的说法吗，整数除法中<code>42 / 24</code>的结果是<code>1</code>，而不是<code>1.75</code>。这里提到的余数，也即是<code>42 % 24</code>得到的<code>18</code>这个结果。</p></div><p>对于除法运算和取余运算，如果除数为0，这个表达式的行为是<a href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p><p>类似于正运算符，加减乘除和取余运算也会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 3</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>int</code> 类型并不是数学意义上的整数，是有范围的，当整数运算的结果超出了 <code>int</code> 类型的范围时，会发生溢出。对于 <code>int</code> 类型，溢出是<a href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。因此，编译器可以认为绝对不会发生溢出，并依此生成代码，这将导致发生溢出时程序的行为不可预测。</p><h2 id="移位表达式" tabindex="-1"><a class="header-anchor" href="#移位表达式"><span>移位表达式</span></a></h2><p>移位表达式的形式是</p><ul><li>①<code>移位表达式 &lt;&lt; 加性表达式</code></li><li>②<code>移位表达式 &gt;&gt; 加性表达式</code></li><li>③<code>加性表达式</code></li></ul><p>其中，<code>&lt;&lt;</code> 表示左移，<code>&gt;&gt;</code> 表示右移。</p><h3 id="移位表达式的计算" tabindex="-1"><a class="header-anchor" href="#移位表达式的计算"><span>移位表达式的计算</span></a></h3><p>移位表达式计算的值是将 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code> 左边的值按照右边的值指定的比特数（位数）进行移位操作的结果。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 168</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>假设 <code>int</code> 是32位的，<code>42</code> 的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0010 1010</code>，左移两位后的二进制表示是 <code>0000 0000 0000 0000 0000 0000 1010 1000</code> （用 <code>0</code> 补充移出来的位），转换为十进制就是 <code>168</code>。</p><p>当结果不超过范围时，读者可以简单地认为左移 <code>N</code> 位就是乘以 <code>2^N</code>。相对的，右移 <code>N</code> 位就是除以 <code>2^N</code>（向下取整）。</p><p>如果左移的结果超过范围，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>42</code>的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0010 1010</code>，左移30位后的二进制表示是 <code>1000 0000 0000 0000 0000 0000 0000 0000</code> （超出范围的位会被舍弃），最后这个结果转换为十进制就是 <code>-2147483648</code>。</p><p>任何情况下，如果移位表达式的右操作数是负数，或者超过了左边值的位数，那么这个表达式的行为是未定义的。</p><p>类似于加性表达式，移位表达式会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 388</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>int</code> 类型的负值，右移操作在左边补充的是 <code>1</code>，而不是 <code>0</code>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 -11</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>-42</code> 的二进制表示是 <code>1111 1111 1111 1111 1111 1111 1101 0110</code>，右移两位后的二进制表示是 <code>1111 1111 1111 1111 1111 1111 1111 0101</code>，转换为十进制就是 <code>-11</code>。显然，即使是负数，右移操作也是向下取整的除以 <code>2^N</code>。需要注意，这里的除法是向下取整的，而非向零取整，即 <code>-42 / (2 ^ 2) = -11 ... 3</code>。于是，容易观察到，如果右移时，右操作数的值是左边的位数，正数会变成 <code>0</code>，而负数会变成 <code>-1</code>。</p><div class="hint-container tip"><p class="hint-container-title">移位强迫症</p><p>设计移位是因为在计算机中，移位操作是非常高效的。在一些情况下，移位操作可以取代乘法和除法，从而提高程序的性能。</p><p>然而，了解到这一点的程序员也会强迫自己一定要写出移位操作，这样的做法是不好的。现代编译器能够将整数乘除2的幂次方的操作优化为移位操作，所以不需要强迫自己写出移位操作。</p><p>程序员应当选择适合当前开发情况的代码，在功能开发期使用高可读性容易重构的代码，在维护优化期使用性能更高的代码。当然，我们最希望的事情是这两个目标能够并行不悖。</p></div><h2 id="关系表达式" tabindex="-1"><a class="header-anchor" href="#关系表达式"><span>关系表达式</span></a></h2><p><strong>比较表达式</strong>、<strong>关系表达式</strong>、<strong>相等表达式</strong>三者组成了 C++ 中的比较关系，它们的形式如下：</p><h3 id="比较表达式" tabindex="-1"><a class="header-anchor" href="#比较表达式"><span>比较表达式</span></a></h3><ul><li>① <code>比较表达式 &lt;=&gt; 移位表达式</code></li><li>② <code>移位表达式</code></li></ul><h3 id="关系表达式-1" tabindex="-1"><a class="header-anchor" href="#关系表达式-1"><span>关系表达式</span></a></h3><ul><li>① <code>关系表达式 &lt; 比较表达式</code></li><li>② <code>关系表达式 &gt; 比较表达式</code></li><li>③ <code>关系表达式 &lt;= 比较表达式</code></li><li>④ <code>关系表达式 &gt;= 比较表达式</code></li><li>⑤ <code>比较表达式</code></li></ul><p>其中，<code>&lt;</code> 表示小于，<code>&gt;</code> 表示大于，<code>&lt;=</code> 表示小于等于，<code>&gt;=</code> 表示大于等于。</p><h3 id="相等表达式" tabindex="-1"><a class="header-anchor" href="#相等表达式"><span>相等表达式</span></a></h3><ul><li>① <code>相等表达式 == 关系表达式</code></li><li>② <code>相等表达式 != 关系表达式</code></li><li>③ <code>关系表达式</code></li></ul><p>其中，<code>==</code> 表示等于，<code>!=</code> 表示不等于。注意，表示等于时，中间的运算符是两个等号 <code>==</code>，而不是一个等号 <code>=</code>。</p><h3 id="关系表达式与相等表达式的计算" tabindex="-1"><a class="header-anchor" href="#关系表达式与相等表达式的计算"><span>关系表达式与相等表达式的计算</span></a></h3><p>比较表达式和关系表达式的结果都是 <code>bool</code> 类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果两边的表达式的类型不同，C++ 会尝试将两边转换为类型大小较大的那个类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，<code>&#39;a&#39;</code> 被转换为 <code>int</code> 类型，然后再进行比较。<code>&#39;a&#39;</code>的ASCII码是65，所以这个比较的结果是 <code>65 &lt; 42</code>，得到 <code>false</code>。</p><p>注意，不要连用两个比较运算符，例如<code>24 &lt; a &lt; 42</code>。这样的表达式会导致计算 <code>24 &lt; a</code> 的结果，得到一个 <code>bool</code> 值，然后这个值（假定为<code>x</code>）再计算 <code>x &lt; 42</code>。这样的计算中，<code>bool</code> 被转换为 <code>int</code> 类型（因为比较的右边是 <code>int</code> 类型），结果<code>x</code>要么是<code>0</code> 要么是 <code>1</code>，然后和 <code>42</code> 比较，这显然不会得到我们想要的结果。</p><h3 id="比较表达式的计算" tabindex="-1"><a class="header-anchor" href="#比较表达式的计算"><span>比较表达式的计算</span></a></h3><p><code>&lt;=&gt;</code> 表示三路比较，<code>&lt;=&gt;</code> 的结果是一个整数，如果左边的值小于右边的值，结果是负数；如果左边的值等于右边的值，结果是0；如果左边的值大于右边的值，结果是正数。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">三路比较是什么？</p><p>技术性地说，<code>int</code> 类型的三路比较的结果是一个 <code>std::strong_ordering</code> 类型的值，包括 <code>less</code>、<code>equal</code>、<code>greater</code> 三个值，这三个值可以与0做比较。这里为了方便理解，简化了三路比较的结果。</p><p><code>std::strong_ordering</code> 表达的是全序关系。对于某个具有全序关系的类型的值 <code>a</code> 、 <code>b</code> 和 <code>c</code>，有：</p><ul><li>反对称性：如果 <code>a &lt;= b</code> 且 <code>b &lt;= a</code> 成立，那么 <code>a == b</code>。</li><li>传递性：如果 <code>a &lt;= b</code> 且 <code>b &lt;= c</code>，那么 <code>a &lt;= c</code>。</li><li>反自反性：<code>a &lt;= a</code> 总是成立。</li></ul><p>这时候，两个数据的比较常常能够用差值的符号性来表示，这样能最大程度利用一次比较的信息量。</p><p>除了全序关系，还有偏序关系 <code>std::partial_ordering</code> 和弱序关系 <code>std::weak_ordering</code>。偏序关系允许类型中存在两个值之间没有比较关系，弱序关系则可以忽略传递性。</p></div><h2 id="按位逻辑表达式" tabindex="-1"><a class="header-anchor" href="#按位逻辑表达式"><span>按位逻辑表达式</span></a></h2><p>按位逻辑表达式有三种：按位与、按位或和按位异或。</p><h3 id="按位与" tabindex="-1"><a class="header-anchor" href="#按位与"><span>按位与</span></a></h3><ul><li>①<code>按位与表达式 &amp; 相等表达式</code></li><li>②<code>相等表达式</code></li></ul><h3 id="按位异或" tabindex="-1"><a class="header-anchor" href="#按位异或"><span>按位异或</span></a></h3><ul><li><code>按位异或表达式 ^ 按位与表达式</code></li><li><code>按位与表达式</code></li></ul><h3 id="按位或" tabindex="-1"><a class="header-anchor" href="#按位或"><span>按位或</span></a></h3><ul><li>①<code>按位或表达式 | 按位异或表达式</code></li><li>②<code>按位异或表达式</code></li></ul><h3 id="按位逻辑表达式的计算" tabindex="-1"><a class="header-anchor" href="#按位逻辑表达式的计算"><span>按位逻辑表达式的计算</span></a></h3><p>按位逻辑表达式的计算是将 <code>&amp;</code>、<code>^</code>、<code>|</code> 左右两边的值按每一位分别进行逻辑运算的结果。</p><p>对于一个比特而言：</p><ul><li>按位与的结果是两个比特都为1时结果为1，否则为0。</li><li>按位或的结果是两个比特都为0时结果为0，否则为1。</li><li>按位异或的结果是两个比特相同时结果为0，否则为1。</li></ul><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 8</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 58</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 50</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>42</code> 的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0010 1010</code>，<code>24</code> 的二进制表示是 <code>0000 0000 0000 0000 0000 0000 0001 1000</code>，按位与的结果是 <code>0000 0000 0000 0000 0000 0000 0000 1000</code>，转换为十进制就是 <code>8</code>。</p><p>按位逻辑表达式会进行<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 99</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="逻辑表达式" tabindex="-1"><a class="header-anchor" href="#逻辑表达式"><span>逻辑表达式</span></a></h2><p>逻辑表达式有两种：逻辑与和逻辑或。</p><h3 id="逻辑与" tabindex="-1"><a class="header-anchor" href="#逻辑与"><span>逻辑与</span></a></h3><ul><li>①<code>逻辑与表达式 &amp;&amp; 按位或表达式</code></li><li>②<code>按位或表达式</code></li></ul><h3 id="逻辑或" tabindex="-1"><a class="header-anchor" href="#逻辑或"><span>逻辑或</span></a></h3><ul><li>①<code>逻辑或表达式 || 逻辑与表达式</code></li><li>②<code>逻辑与表达式</code></li></ul><h3 id="逻辑表达式的计算" tabindex="-1"><a class="header-anchor" href="#逻辑表达式的计算"><span>逻辑表达式的计算</span></a></h3><p>逻辑表达式的计算是将 <code>&amp;&amp;</code>、<code>||</code> 左右两边的值按照逻辑运算的结果。这会将左右两边的值转换为 <code>bool</code> 类型，然后进行逻辑运算。</p><p>其中：</p><ul><li>逻辑与的结果是两个值都为 <code>true</code> 时结果为 <code>true</code>，否则为 <code>false</code>。</li><li>逻辑或的结果是两个值都为 <code>false</code> 时结果为 <code>false</code>，否则为 <code>true</code>。</li></ul><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，逻辑表达式是短路的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值一定是 <code>false</code>，因为逻辑与的左边是 <code>false</code>。此时，C++规定不会计算右边<code>a</code>的值，直接返回 <code>false</code>。类似的，如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值一定是 <code>true</code>，因为逻辑或的左边是 <code>true</code>。此时，C++规定不会计算右边<code>a</code>的值，直接返回 <code>true</code>。</p><p>在之后，当我们了解到表达式的副作用时，我们会进一步讨论逻辑表达式的短路。</p>`,84),u={class:"hint-container tip"},b=i('<p class="hint-container-title">逻辑表达式的计算顺序</p><p>读者可以发现，从关系表达式到逻辑表达式，有着一层一层严格的组合关系。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式被唯一解释为如下图的计算过程：</p>',5),E=i('<p>现在正看着这个文档的人可能会觉得这个计算顺序很明显。但是在开发的时候，每写一个表达式都要考虑计算顺序，是一件非常繁琐且降低效率的事情。</p><p>与其把时间消耗在反复训练以熟练掌握这个计算顺序，不如把时间消耗在提高代码质量上。在实际开发中，我们可以多用<code>()</code>括号，将复杂的组合表达式变为基本表达式。这样，不仅解决了计算顺序的问题，还可以提高代码的可读性。</p><p>例如，上面的表达式可以写成：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样计算顺序就变得非常明显了。</p>',5),y=i('<h2 id="条件表达式" tabindex="-1"><a class="header-anchor" href="#条件表达式"><span>条件表达式</span></a></h2><p>C++ 中的条件表达式又叫做三目运算、三元表达式等名称，其形式是</p><ul><li>① <code>逻辑或表达式</code></li><li>② <code>逻辑或表达式 ? 表达式 : 赋值表达式</code></li></ul><p>标点符号 <code>?</code> 和 <code>:</code> 是条件表达式的标志，为了方便表述，这里将 <code>?</code> 左边的表达式称为 操作数1，将 <code>:</code> 左边、<code>?</code> 右边的表达式称为 操作数2，将 <code>:</code> 右边的表达式称为 操作数3。</p><p>条件表达式的计算是先计算操作数1，如果操作数1转换到<code>bool</code>后的值<code>true</code>，则计算操作数2，否则计算操作数3（类似于逻辑表达式的短路行为，另一个操作数不会计算）。</p><p>整个表达式的值是操作数2或操作数3的值，取决于计算了哪一个操作数。</p><h2 id="赋值表达式" tabindex="-1"><a class="header-anchor" href="#赋值表达式"><span>赋值表达式</span></a></h2><p>赋值表达式的形式是：</p><ul><li>①<code>条件表达式</code></li><li>②<code>逻辑或表达式 = 赋值表达式</code></li></ul><p>以及一系列的复合赋值表达式：</p><ul><li>③<code>逻辑或表达式 += 赋值表达式</code></li><li>④<code>逻辑或表达式 -= 赋值表达式</code></li><li>⑤<code>逻辑或表达式 *= 赋值表达式</code></li><li>⑥<code>逻辑或表达式 /= 赋值表达式</code></li><li>⑦<code>逻辑或表达式 %= 赋值表达式</code></li><li>⑧<code>逻辑或表达式 &lt;&lt;= 赋值表达式</code></li><li>⑨<code>逻辑或表达式 &gt;&gt;= 赋值表达式</code></li><li>⑩<code>逻辑或表达式 &amp;= 赋值表达式</code></li><li>⑪<code>逻辑或表达式 ^= 赋值表达式</code></li><li>⑫<code>逻辑或表达式 |= 赋值表达式</code></li></ul><h3 id="赋值表达式的计算" tabindex="-1"><a class="header-anchor" href="#赋值表达式的计算"><span>赋值表达式的计算</span></a></h3><p>赋值是 C++ 中一种操作的名称，对于 <code>int</code>、<code>bool</code>、<code>char</code> 这三种基本类型，赋值的操作是将一个对象的值改变为另一个值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的作用是将 <code>a</code> 的值改变为 <code>42</code>。对于②形式的赋值表达式，其计算是先计算右边的赋值表达式，然后将计算结果赋值给左边的逻辑或表达式。</p><div class="hint-container info"><p class="hint-container-title">等于号</p><p>在数学中，等于号有很多含义，例如定义函数、表示等价、表示等于关系。但是在 C++ 中，等于号的含义是赋值。这个含义与数学中任何含义都不同，对于初学者需要注意。</p></div><p>赋值表达式的值是赋值完成后 <code>=</code> 左边的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式的值为 42，并表示 a 这个对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这意味着可以写出如下的表达式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 <code>a</code> 先被赋值为 <code>42</code>，然后再被赋值为 <code>24</code>。这个表达式的值是 <code>24</code>。</p><p>注意，赋值表达式的组合方式和前面的表达式不同。例如，加性表达式的结构是</p><ul><li>①<code>加性表达式 + 乘性表达式</code></li></ul><p>这里加性表达式在左边，乘性表达式在右边。而赋值表达式的结构是</p><ul><li>②<code>逻辑或表达式 = 赋值表达式</code></li></ul><p>这里赋值表达式在左边，逻辑或表达式在右边。</p><p>考虑如下的表达式：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个赋值表达式的结构实际上是</p>',29),v=i('<p>也即是说，这个表达式会先计算 <code>b = 42</code>，然后再计算 <code>a = b = 42</code>。也即从右往左计算的。</p><h3 id="复合赋值表达式" tabindex="-1"><a class="header-anchor" href="#复合赋值表达式"><span>复合赋值表达式</span></a></h3><p>复合赋值表达式是复合操作的赋值表达式，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>等价于</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>技术性地说，对于 <code>op</code> 运算符，<code>a op= b</code> 等价于 <code>a = a op b</code>。除了这里的 <code>a</code> 表达式只计算一次，其他的计算过程和先计算再赋值时是一样的。</p><h3 id="副作用" tabindex="-1"><a class="header-anchor" href="#副作用"><span>副作用</span></a></h3><p>在 C++ 中，表达式的计算可能会产生副作用，副作用会影响表达式以外的程序部分。</p><p>除了赋值表达式，前面介绍过的<a href="#%E5%89%8D%E7%BC%80%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6">前缀自增运算符</a>、<a href="#%E5%89%8D%E7%BC%80%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">前缀自减运算符</a>、<a href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6">后缀自增运算符</a>、<a href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">后缀自减运算符</a>也能产生副作用。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式除了会改变 <code>b</code> 的值，还会改变 <code>a</code> 的值。这里的 <code>a = 42</code> 是一个赋值表达式，它的值是 <code>42</code>，然后再计算 <code>42 + 24</code>，最后将结果 <code>66</code> 赋值给 <code>b</code>。</p><p>赋值表达式规定了先计算右边的表达式，再计算左边的表达式，最后进行赋值。这样的规定使得如<code>a += a += 1</code>这样的表达式是符合语法的，这里的计算过程是先计算右边的<code>a += 1</code>，得到这个表达式的值<code>x</code>，然后再计算左边的<code>a += x</code>。但显然这样的表达式的可读性比较糟糕，在开发中应当避免这样使用。</p><p>在前面逻辑表达式的短路中，我们提到了逻辑表达式的短路行为。这种短路行为会导致逻辑表达式的副作用不会发生。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值是 <code>false</code>，并且 <code>a = 42</code> 不会计算，<code>a</code> 的值不会改变。类似的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表达式的值是 <code>true</code>，并且 <code>a = 42</code> 不会计算，<code>a</code> 的值不会改变。</p><h3 id="不确定值" tabindex="-1"><a class="header-anchor" href="#不确定值"><span>不确定值</span></a></h3>',19),m=i(`<p>虽然不能使用具有不确定值的对象的值，但是可以对其进行赋值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是不确定的</span></span>
<span class="line highlighted error"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// int b = a;// 错误，不能使用 a 的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可以对 a 进行赋值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 现在 a 的值是确定的，可以使用 a 的值了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="能不能赋值" tabindex="-1"><a class="header-anchor" href="#能不能赋值"><span>能不能赋值？</span></a></h3><p>赋值表达式的左边并不能是任意的表达式，例如</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是因为 <code>a + b</code> 得到的是一个临时的值，并不指代对象，所以不能对其赋值。赋值表达式的左边必须是一个能够指代对象的表达式。</p><p>在这一节中，已经提到了前缀自增、前缀自减、赋值表达式、复合赋值表达式等表达式的值是能指代对象的。这意味着下面的表达式是符合语法的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相对的后缀自增、后缀自减、取反运算符等表达式会导致表达式不再能赋值。注意，<a href="#%E6%AD%A3%E8%BF%90%E7%AE%97%E7%AC%A6">正运算符</a>对于 <code>int</code> 类型虽然不会让值发生变化，但也是如此。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span>
<span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span>
<span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span>
<span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，前缀自增、前缀自减、后缀自增、后缀自减等表达式对参数做出修改，性质上也是赋值。这意味着其操作数如果不是可赋值的，则会产生错误。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">前缀与后缀的差异</p><p>前缀自增、前缀自减、后缀自增、后缀自减的差异是延续自 C 语言的设计。</p><p>早年编译器优化能力的匮乏使得程序员之间流传着 “后缀自增会产生一个临时对象从而损失性能” 的传说，在 21 世纪，这种传说已经不再成立。</p><p>自增自减的这种差异也常常会带来阅读上的困扰，因此在实际开发中，应当尽可能简略且明确地使用自增自减，避免把它结合进复杂的表达式中。</p></div><p>此外，如果 <code>()</code> 内的表达式是能指代对象的，那么这个基础表达式也指代这个对象，从而可以赋值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，如果<a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件表达式</a>的操作数2和操作数3能指代对象，且是相同的类型，那么条件表达式的值也是能指代对象的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 符合语法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，赋值表达式左边不能直接是条件表达式，需要使用括号将它变成基础表达式</p><h2 id="逗号表达式" tabindex="-1"><a class="header-anchor" href="#逗号表达式"><span>逗号表达式</span></a></h2><p>逗号表达式的形式是</p><ul><li>①<code>逗号表达式 , 赋值表达式</code></li><li>②<code>赋值表达式</code></li></ul><p>这里将逗号表达式中，&#39;,&#39;的左边称为操作数1，右边称为操作数2。</p><p>逗号表达式的计算是先计算操作数1，然后计算操作数2，最后返回操作数2的值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>逗号表达式也可以连续使用，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 66</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为 66</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>注意，在特定语境下，逗号不会被解释为逗号表达式。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的逗号不是逗号表达式，而是用来分隔不同的声明的。</p><p>除此之外还有函数调用、初始化列表等语境下，逗号也不会被解释为逗号表达式。这些内容会在后续章节中介绍。</p></div><h2 id="无法确定顺序的副作用" tabindex="-1"><a class="header-anchor" href="#无法确定顺序的副作用"><span>无法确定顺序的副作用</span></a></h2><p>在本节前面的内容中，介绍了一些有序的表达式，例如赋值表达式、复合赋值表达式、逗号表达式等。这样的表达式中，出现了多个对相同对象的副作用时，其作用是确定的，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // i 的值是 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的赋值表达式，先计算左边表达式，再计算右边表达式，最后赋值。其计算过程是：</p><ol><li>先计算左边，<code>i</code> 表达式的值是 <code>1</code>，且表示 <code>i</code> 对象。</li><li>再计算右边，<code>++i + 2</code> 表达式的值是 <code>4</code>，发生副作用，<code>i</code> 的值变为 <code>2</code>。</li><li>最后赋值，<code>i</code> 的值变为 <code>4</code>。</li></ol><p>但是，并不是所有的表达式都是有序的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 <code>++i</code> 和 <code>i++</code> 都会对 <code>i</code> 产生副作用，但是 C++ 规定 <code>+</code> 两边的表达式的计算是无顺序的。</p><p>对这样的表达式求值是错误的，无论是在学习还是在实际开发中，都应当避免写出这样的表达式。</p><h2 id="进一步理解初始化" tabindex="-1"><a class="header-anchor" href="#进一步理解初始化"><span>进一步理解初始化</span></a></h2><p>在前文，我们提到初始化的概念，声明并初始化的语法结构是：<code>类型 标识符 初始化器;</code></p><p>之前我们认为初始化器是<code>= 字面量</code>，例如<code>int a = 42;</code>，<code>= 42</code>就是初始化器。现在，我们可以进一步理解初始化器，初始化器可以是<code>= 赋值表达式</code>。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里b的初始化器是<code>= 42 + a</code>，这个初始化器是<code>= 表达式</code>，这个生命会将<code>b</code>指代的对象初始化为<code>42 + a</code>的值。</p><p>初始化器中能出现赋值表达式（当然也因此而包括了赋值表达式所有的组件）。这意味着下列代码是符合语法的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，由于初始化器是<code>= 赋值表达式</code>，所以初始化器中不能出现逗号表达式。初始化器中的逗号有另外的含义，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的逗号不是逗号表达式，而是分隔了两个声明。这里分别声明了<code>a</code>和<code>b</code>，并分别初始化为<code>42</code>和<code>24</code>。</p><p>我们可以把以下两种形式统称为初始化声明</p><ul><li><code>标识符</code></li><li><code>标识符 = 赋值表达式</code></li></ul><p>那么，初始化就可以理解为</p><p><code>类型 初始化声明 , 初始化声明 , 初始化声明 ... ;</code></p><p>这样的结构，到此已经基本接近了完整的 C++ 初始化语法。</p><h2 id="快速练习" tabindex="-1"><a class="header-anchor" href="#快速练习"><span>快速练习</span></a></h2>`,52);function F(A,D){const e=a("Mermaid"),d=a("RouteLink"),n=a("Choices");return p(),k("div",null,[g,s(e,{id:"mermaid-367",code:"eJxLL0osyFAIceJSAIIkXV270qRopSSNJzsanrY2v1i44sW+fU/39GsqxYIVlIJU5EJU7JzxrGE5hopckIqS6CQFLYVkiEgyyNDkaKVknIaCVKBoSQRpSYxWSsSpBaQiF6ICwx1AqUSw1NOuBdicmAjSXBGdqKCtgGRnCUiQCwARjWv7"}),o,h("div",u,[b,s(e,{id:"mermaid-799",code:"eJxljTsOhDAMRPucYpSCDilQryj2DNtFFE4iLV0QJeLw+Fcg4cLy2G/G/4P2Db9vABdpL9qr9XFcak05VixIcdXlOeW02sEMPFMRqmAY8EQZ8WNQ3Vj1lhs+SB42W1hvRpDxU46E68IrUbIccQNPtphfHlH6y81d/gsZbqn7OAw="}),E]),y,s(e,{id:"mermaid-970",code:"eJxLL0osyFAIceJSAIIkXV27pFQTo2ilJAVbBRMjpViwcF60iRGUBVUA5iQCOWnRSolApSjKQQpAUlwA3H0UVQ=="}),v,h("p",null,[l("在初识声明的"),s(d,{to:"/zh/02-program-structure/declaration.html#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%80%BC"},{default:c(()=>[l("不确定值")]),_:1}),l("一节中提到，如果一个对象声明时没有初始化器，则会初始化为不确定值。")]),m,s(n,{questions:[{text:"下面的表达式的值是",code:"42 > 24 > 12",shuffleOptions:!1,options:["true","false","语法错误"],answers:["false"]},{text:"下面的表达式的值是",code:"true + true",shuffleOptions:!1,options:["2","1","0","true","false","语法错误"],answers:["2"]},{text:"下面的表达式的值是",code:"1 << '\\n'",shuffleOptions:!1,options:["1024","128","10","1","0","语法错误"],answers:["1024"]}]})])}const B=t(r,[["render",F],["__file","expression.html.vue"]]),x=JSON.parse('{"path":"/zh/02-program-structure/expression.html","title":"2.2 初识表达式","lang":"zh-CN","frontmatter":{"title":"2.2 初识表达式"},"headers":[{"level":2,"title":"操作数","slug":"操作数","link":"#操作数","children":[]},{"level":2,"title":"未定义行为","slug":"未定义行为","link":"#未定义行为","children":[]},{"level":2,"title":"基本表达式","slug":"基本表达式","link":"#基本表达式","children":[]},{"level":2,"title":"后缀表达式","slug":"后缀表达式","link":"#后缀表达式","children":[{"level":3,"title":"后缀自增运算符","slug":"后缀自增运算符","link":"#后缀自增运算符","children":[]},{"level":3,"title":"后缀自减运算符","slug":"后缀自减运算符","link":"#后缀自减运算符","children":[]}]},{"level":2,"title":"一元表达式","slug":"一元表达式","link":"#一元表达式","children":[{"level":3,"title":"正运算符","slug":"正运算符","link":"#正运算符","children":[]},{"level":3,"title":"整数提升","slug":"整数提升","link":"#整数提升","children":[]},{"level":3,"title":"负运算符","slug":"负运算符","link":"#负运算符","children":[]},{"level":3,"title":"按位取反","slug":"按位取反","link":"#按位取反","children":[]},{"level":3,"title":"逻辑非","slug":"逻辑非","link":"#逻辑非","children":[]},{"level":3,"title":"前缀自增运算符","slug":"前缀自增运算符","link":"#前缀自增运算符","children":[]},{"level":3,"title":"前缀自减运算符","slug":"前缀自减运算符","link":"#前缀自减运算符","children":[]}]},{"level":2,"title":"加性表达式和乘性表达式","slug":"加性表达式和乘性表达式","link":"#加性表达式和乘性表达式","children":[{"level":3,"title":"乘性表达式","slug":"乘性表达式","link":"#乘性表达式","children":[]},{"level":3,"title":"加性表达式","slug":"加性表达式","link":"#加性表达式","children":[]},{"level":3,"title":"整数的加减乘除与取余计算","slug":"整数的加减乘除与取余计算","link":"#整数的加减乘除与取余计算","children":[]}]},{"level":2,"title":"移位表达式","slug":"移位表达式","link":"#移位表达式","children":[{"level":3,"title":"移位表达式的计算","slug":"移位表达式的计算","link":"#移位表达式的计算","children":[]}]},{"level":2,"title":"关系表达式","slug":"关系表达式","link":"#关系表达式","children":[{"level":3,"title":"比较表达式","slug":"比较表达式","link":"#比较表达式","children":[]},{"level":3,"title":"关系表达式","slug":"关系表达式-1","link":"#关系表达式-1","children":[]},{"level":3,"title":"相等表达式","slug":"相等表达式","link":"#相等表达式","children":[]},{"level":3,"title":"关系表达式与相等表达式的计算","slug":"关系表达式与相等表达式的计算","link":"#关系表达式与相等表达式的计算","children":[]},{"level":3,"title":"比较表达式的计算","slug":"比较表达式的计算","link":"#比较表达式的计算","children":[]}]},{"level":2,"title":"按位逻辑表达式","slug":"按位逻辑表达式","link":"#按位逻辑表达式","children":[{"level":3,"title":"按位与","slug":"按位与","link":"#按位与","children":[]},{"level":3,"title":"按位异或","slug":"按位异或","link":"#按位异或","children":[]},{"level":3,"title":"按位或","slug":"按位或","link":"#按位或","children":[]},{"level":3,"title":"按位逻辑表达式的计算","slug":"按位逻辑表达式的计算","link":"#按位逻辑表达式的计算","children":[]}]},{"level":2,"title":"逻辑表达式","slug":"逻辑表达式","link":"#逻辑表达式","children":[{"level":3,"title":"逻辑与","slug":"逻辑与","link":"#逻辑与","children":[]},{"level":3,"title":"逻辑或","slug":"逻辑或","link":"#逻辑或","children":[]},{"level":3,"title":"逻辑表达式的计算","slug":"逻辑表达式的计算","link":"#逻辑表达式的计算","children":[]}]},{"level":2,"title":"条件表达式","slug":"条件表达式","link":"#条件表达式","children":[]},{"level":2,"title":"赋值表达式","slug":"赋值表达式","link":"#赋值表达式","children":[{"level":3,"title":"赋值表达式的计算","slug":"赋值表达式的计算","link":"#赋值表达式的计算","children":[]},{"level":3,"title":"复合赋值表达式","slug":"复合赋值表达式","link":"#复合赋值表达式","children":[]},{"level":3,"title":"副作用","slug":"副作用","link":"#副作用","children":[]},{"level":3,"title":"不确定值","slug":"不确定值","link":"#不确定值","children":[]},{"level":3,"title":"能不能赋值？","slug":"能不能赋值","link":"#能不能赋值","children":[]}]},{"level":2,"title":"逗号表达式","slug":"逗号表达式","link":"#逗号表达式","children":[]},{"level":2,"title":"无法确定顺序的副作用","slug":"无法确定顺序的副作用","link":"#无法确定顺序的副作用","children":[]},{"level":2,"title":"进一步理解初始化","slug":"进一步理解初始化","link":"#进一步理解初始化","children":[]},{"level":2,"title":"快速练习","slug":"快速练习","link":"#快速练习","children":[]}],"git":{"createdTime":1719648113000,"updatedTime":1722144392000,"contributors":[{"name":"dynilath","email":"dynilath@qq.com","commits":18}]},"readingTime":{"minutes":29.72,"words":8915},"filePathRelative":"zh/02-program-structure/expression.md","localizedDate":"2024年6月29日"}');export{B as comp,x as data};
