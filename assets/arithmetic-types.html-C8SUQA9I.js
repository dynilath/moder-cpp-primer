import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as c,c as o,d as s,e as i,a as t,w as e,b as a}from"./app-DNTRvR-x.js";const p={},r=a(`<p>算术类型是一类能对数据进行算术运算的类型。C++ 中的算术类型包括<strong>整数类型</strong>和<strong>浮点类型</strong>。</p><h2 id="整数类型" tabindex="-1"><a class="header-anchor" href="#整数类型"><span>整数类型</span></a></h2><p>在前面的章节中，为了介绍表达式，介绍了三种类型 <code>int</code>、<code>bool</code> 和 <code>char</code>，这些类型都是整数类型。这里我们详细介绍整数类型。</p><p>C++ 中默认提供的整数类型包括：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型大小</th></tr></thead><tbody><tr><td><code>short int</code></td><td>短整数类型</td><td>没有字面量</td><td>至少 2</td></tr><tr><td><code>unsigned short int</code></td><td>无符号短整数类型</td><td>没有字面量</td><td>至少 2</td></tr><tr><td><code>int</code></td><td>整数类型</td><td><code>123</code>，没有后缀</td><td>至少 2，且不小于 <code>short</code>。</td></tr><tr><td><code>unsigned int</code></td><td>无符号整数类型</td><td><code>123u</code>，后缀<code>u</code>，不区分大小写</td><td>至少 2，且不小于 <code>short</code>。</td></tr><tr><td><code>long int</code></td><td>长整数类型</td><td><code>123l</code>，后缀<code>l</code>，不区分大小写</td><td>至少 4，且不小于 <code>int</code>。</td></tr><tr><td><code>unsigned long int</code></td><td>无符号长整数类型</td><td><code>123ul</code>，后缀<code>ul</code>，不区分大小写</td><td>至少 4，且不小于 <code>int</code>。</td></tr><tr><td><code>long long int</code></td><td>长长整数类型</td><td><code>123ll</code>，后缀<code>ll</code>，不区分大小写</td><td>至少 8，且不小于 <code>long</code>。</td></tr><tr><td><code>unsigned long long int</code></td><td>无符号长长整数类型</td><td><code>123ull</code>，后缀<code>ull</code>，不区分大小写</td><td>至少 8，且不小于 <code>long</code>。</td></tr></tbody></table><p>上面提到的这些类型，字面量的后缀 <code>u</code>、<code>l</code>、<code>ll</code> 不区分大小写，并且 <code>u</code> 和 <code>l</code> / <code>ll</code> 的顺序任意，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">U</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 值为123，类型为 unsigned int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 unsigned long int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">lu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 unsigned long int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 long long int</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LLU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 值为123，类型为 unsigned long long int</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，不可以写作 <code>123lul</code></p><p>上面描述的这些类型的名字由多个关键字组成，其中的一部分是可以省略、或者无影响地添加的：</p><table><thead><tr><th>类型</th><th>等同的类型</th><th>最短形式</th></tr></thead><tbody><tr><td><code>short int</code></td><td><code>short</code>、<code>signed short</code>、<code>signed short int</code></td><td><code>short</code></td></tr><tr><td><code>unsigned short int</code></td><td><code>unsigned short</code></td><td><code>unsigned short</code></td></tr><tr><td><code>int</code></td><td><code>signed</code>、<code>signed int</code></td><td><code>int</code></td></tr><tr><td><code>unsigned int</code></td><td><code>unsigned</code></td><td><code>unsigned</code></td></tr><tr><td><code>long int</code></td><td><code>long</code>、<code>signed long</code>、<code>signed long int</code></td><td><code>long</code></td></tr><tr><td><code>unsigned long int</code></td><td><code>unsigned long</code></td><td><code>unsigned long</code></td></tr></tbody></table><p>组成这些类型关键词顺序是任意的，例如 <code>signed int</code> 和 <code>int signed</code> 是等价的、<code>unsigned long long int</code> 和 <code>int long unsigned long</code> 也是等价的。</p><div class="hint-container info"><p class="hint-container-title">语言习惯</p><p>上面提到的 <code>int long unsigned long</code> 虽然是符合语法的，但是人类在描述一件事物的时候，使用限定语通常会有一定的顺序。例如“一个大圆红苹果”很少有人会说成“红大一个圆苹果”。在使用多关键词类型名的时候，往往习惯于按照符号性、大小、中心词<code>int</code>的顺序来描述类型。</p></div>`,12),k=a(`<div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将 my_int 定义为 int 的别名</span></span>
<span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_int x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：long my_int 不能组成 long int</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上述用于表示基本整数的类型，C++ 还提供了一些用于表示字符的整数类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型大小</th></tr></thead><tbody><tr><td><code>signed char</code></td><td>有符号字符类型</td><td>没有字面量</td><td>1</td></tr><tr><td><code>unsigned char</code></td><td>无符号字符类型</td><td>没有字面量</td><td>1</td></tr><tr><td><code>char</code></td><td>字符类型</td><td><code>&#39;A&#39;</code></td><td>1</td></tr><tr><td><code>char8_t</code></td><td>UTF-8 字符类型</td><td><code>u8&#39;A&#39;</code>，u8前缀</td><td>1，与 <code>unsigned char</code> 相同</td></tr><tr><td><code>char16_t</code></td><td>UTF-16 字符类型</td><td><code>u&#39;A&#39;</code>，u前缀</td><td>与 <code>std::uint_least16_t</code> 相同</td></tr><tr><td><code>char32_t</code></td><td>UTF-32 字符类型</td><td><code>U&#39;A&#39;</code>，大写U前缀</td><td>与 <code>std::uint_least32_t</code> 相同</td></tr><tr><td><code>wchar_t</code></td><td>宽字符类型</td><td><code>L&#39;A&#39;</code>，大写L前缀</td><td>由平台决定</td></tr></tbody></table><p><code>char</code> 是字符类型，属于整数类型，它与 <code>signed char</code> 或者 <code>unsigned char</code> 之一的值表示相同，但是从语言上 <code>char</code> 类型是一个独立的类型，与 <code>signed char</code> 和 <code>unsigned char</code> 均不同。</p><p><code>char8_t</code> 是 UTF-8 字符类型，属于整数类型。它和 <code>unsigned char</code> 有相同的大小和符号性、大小和对齐，但它是和 <code>unsigned char</code> 不同的类型。</p><p><code>char16_t</code> 是 UTF-16 字符类型，属于整数类型。它的大小足够表示一个 UTF-16 编码单元。它和 <code>std::uint_least16_t</code> 有相同的大小和符号性、大小和对齐，但它是和 <code>std::uint_least16_t</code> 不同的类型（见后文）。</p><p><code>char32_t</code> 是 UTF-32 字符类型，属于整数类型。它的大小足够表示一个 UTF-32 编码单元。它和 <code>std::uint_least32_t</code> 有相同的大小和符号性、大小和对齐，但它是和 <code>std::uint_least32_t</code> 不同的类型（见后文）。</p><p><code>wchar_t</code> 是宽字符类型，属于整数类型，它的大小由平台决定，通常是2字节或者4字节。</p><p>在上面列出的类型中，<code>signed char</code>、<code>short</code>、<code>int</code>、<code>long int</code>、<code>long long int</code>称为<strong>基础有符号整数类型</strong>；<code>unsigned char</code>、<code>unsigned short</code>、<code>unsigned int</code>、<code>unsigned long int</code>、<code>unsigned long long int</code>称为<strong>基础无符号整数类型</strong>；<code>char</code>、<code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code>称为<strong>字符类型</strong>。基础有符号整数类型和基础无符号整数类型合起来称为<strong>基础整数类型</strong>。</p><p>除了上述的整数类型之外，C++ 还提供了一些特殊的整数类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型大小</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔类型</td><td><code>true</code>、<code>false</code></td><td>实现定义</td></tr><tr><td><code>std::size_t</code></td><td>表示对象的大小的无符号整数类型</td><td><code>123uz</code>，后缀<code>uz</code>，不区分大小写</td><td>实现定义</td></tr><tr><td></td><td>有符号形式的 <code>std::size_t</code></td><td><code>123z</code>，后缀<code>z</code>，不区分大小写</td><td>实现定义</td></tr><tr><td><code>std::ptrdiff_t</code></td><td>有符号整数类型，用于指针差值</td><td></td><td>实现定义</td></tr></tbody></table><p><code>bool</code> 是布尔类型，属于整数类型，它只有两个值 <code>true</code> 和 <code>false</code>。<code>bool</code> 类型的大小 C++ 没有规定，但是通常为1字节。</p><p><code>std::size_t</code> 是用于表示对象的大小的无符号整数类型。是 <code>sizeof</code> 和 <code>alignof</code> 运算符的结果类型。<code>std::size_t</code> 的大小由平台决定，且 <code>std::size_t</code> 实现通常是前述整数类型之一的类型别名。</p><p><code>std::ptrdiff_t</code> 是用于表示指针差值的整数类型。它足够容纳两个指针之间的差值。我们会在后面的章节中介绍指针类型。</p><h3 id="一些实现的类型大小" tabindex="-1"><a class="header-anchor" href="#一些实现的类型大小"><span>一些实现的类型大小</span></a></h3><p>下表展示了不同实现的整数类型的位宽。</p><table><thead><tr><th>数据模型</th><th><code>short int</code></th><th><code>int</code></th><th><code>long int</code></th><th><code>long long int</code></th><th><code>std::size_t</code></th><th>典型平台</th></tr></thead><tbody><tr><td></td><td>16</td><td>16</td><td>32</td><td>64</td><td></td><td>C++ 标准规定的最小位宽</td></tr><tr><td>ILP32</td><td>16</td><td>32</td><td>32</td><td>64</td><td>32</td><td>x86-32</td></tr><tr><td>LLP64</td><td>16</td><td>32</td><td>32</td><td>64</td><td>64</td><td>Windows（包括 x86-64，IA-64，ARM64）</td></tr><tr><td>LP64</td><td>16</td><td>32</td><td>64</td><td>64</td><td>64</td><td>Unix和多数类Unix系统，如Linux，macOS，Solaris</td></tr><tr><td>ILP64</td><td>16</td><td>64</td><td>64</td><td>64</td><td>64</td><td>一些科学计算领域的平台，如Cray</td></tr><tr><td>SILP64</td><td>64</td><td>64</td><td>64</td><td>64</td><td>64</td><td>Classic UNICOS</td></tr><tr><td></td><td>16</td><td>16</td><td>32</td><td>64</td><td>16 (是 <code>unsigned int</code> 的别名)</td><td>嵌入式系统，如AVR</td></tr><tr><td></td><td>8</td><td>8</td><td>16</td><td>32</td><td>16 (是 <code>long unsigned int</code>的别名)</td><td>嵌入式系统，如AVR（int8模式）</td></tr></tbody></table><h3 id="扩展整数类型" tabindex="-1"><a class="header-anchor" href="#扩展整数类型"><span>扩展整数类型</span></a></h3><p>除了上述的整数类型之外，根据实现，C++ 也会提供另外的扩展整数类型，其中典型的就是定宽整数类型。这些类型有：</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><code>std::int8_t</code></td><td>有符号8位整数</td><td>可选提供</td></tr><tr><td><code>std::int16_t</code></td><td>有符号16位整数</td><td>可选提供</td></tr><tr><td><code>std::int32_t</code></td><td>有符号32位整数</td><td>可选提供</td></tr><tr><td><code>std::int64_t</code></td><td>有符号64位整数</td><td>可选提供</td></tr><tr><td><code>std::uint8_t</code></td><td>无符号8位整数</td><td>可选提供</td></tr><tr><td><code>std::uint16_t</code></td><td>无符号16位整数</td><td>可选提供</td></tr><tr><td><code>std::uint32_t</code></td><td>无符号32位整数</td><td>可选提供</td></tr><tr><td><code>std::uint64_t</code></td><td>无符号64位整数</td><td>可选提供</td></tr><tr><td><code>std::int_fast8_t</code></td><td>至少8位的最快整数类型</td><td></td></tr><tr><td><code>std::int_fast16_t</code></td><td>至少16位的最快整数类型</td><td></td></tr><tr><td><code>std::int_fast32_t</code></td><td>至少32位的最快整数类型</td><td></td></tr><tr><td><code>std::int_fast64_t</code></td><td>至少64位的最快整数类型</td><td></td></tr><tr><td><code>std::uint_fast8_t</code></td><td>至少8位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::uint_fast16_t</code></td><td>至少16位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::uint_fast32_t</code></td><td>至少32位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::uint_fast64_t</code></td><td>至少64位的最快无符号整数类型</td><td></td></tr><tr><td><code>std::int_least8_t</code></td><td>至少8位的最小整数类型</td><td></td></tr><tr><td><code>std::int_least16_t</code></td><td>至少16位的最小整数类型</td><td></td></tr><tr><td><code>std::int_least32_t</code></td><td>至少32位的最小整数类型</td><td></td></tr><tr><td><code>std::int_least64_t</code></td><td>至少64位的最小整数类型</td><td></td></tr><tr><td><code>std::uint_least8_t</code></td><td>至少8位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::uint_least16_t</code></td><td>至少16位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::uint_least32_t</code></td><td>至少32位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::uint_least64_t</code></td><td>至少64位的最小无符号整数类型</td><td></td></tr><tr><td><code>std::intmax_t</code></td><td>最大位宽有符号整数类型</td><td></td></tr><tr><td><code>std::uintmax_t</code></td><td>最大位宽无符号整数类型</td><td></td></tr><tr><td><code>std::intptr_t</code></td><td>整数类型，用于指针</td><td></td></tr><tr><td><code>std::uintptr_t</code></td><td>无符号整数类型，用于指针</td><td></td></tr></tbody></table><p>这些类型的名字不是关键字，因此以 <code>std::</code> 作为前缀。</p><p><code>std::int8_t</code>、<code>std::int16_t</code>等定宽整数类型的位宽是确定的，它仅当实现直接提供这样尺寸的整数类型时才会存在。如果前面提到的如 <code>int</code> <code>long int</code> 这样的类型本身就满足定宽的要求，那么这些定宽类型可以是对应的类型的别名。例如，如果某个实现中 <code>int</code> 恰好是32位的，那么允许 <code>using int32_t = int;</code> 来声明 <code>std::int32_t</code> 类型。</p><p><code>std::int_fast8_t</code>、<code>std::int_fast16_t</code>等最快整数类型是指在当前平台上最快的整数类型，它们的位宽是不确定的，但是至少是指定的位宽。由于平台上最快的整数类型是 <code>int</code>, 因此尺寸小于 <code>int</code> 的最快整数类型往往是 <code>int</code>。</p><p>实现可以提供 <code>N</code> 不在上述之列的 <code>std::intN_t</code>，<code>std::int_fastN_t</code> 和 <code>std::int_leastN_t</code> 等类型，但也必须满足 <code>std::intN_t</code> 的位宽是 <code>N</code>，<code>std::int_fastN_t</code> 和 <code>std::int_leastN_t</code> 的位宽至少是 <code>N</code>。</p><p><code>std::intptr_t</code> 和 <code>std::uintptr_t</code> 是用于指针的整数类型。<code>std::intptr_t</code> 是有符号整数类型，<code>std::uintptr_t</code> 是无符号整数类型。它们足够容纳对象指针类型的位宽。</p><h3 id="整数类型的运算" tabindex="-1"><a class="header-anchor" href="#整数类型的运算"><span>整数类型的运算</span></a></h3>`,26),g=s("code",null,"int",-1),E=s("code",null,"int",-1),u=s("code",null,"int",-1),y=a(`<p>但是，对于无符号整数类型，例如 <code>unsigned int</code>，标准保证运算是模运算。即，如果结果超出了类型的范围，那么结果会被取模到类型的范围内。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假定 unsigned int 是 32 位，因此 4294967295 是此类型的最大值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4294967295</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保证 a + b 的结果，以及 c 的值是 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="整数提升" tabindex="-1"><a class="header-anchor" href="#整数提升"><span>整数提升</span></a></h3>`,3),A=s("code",null,"bool",-1),b=s("code",null,"char",-1),F=s("code",null,"int",-1),v=a(`<p>这个规则具体而言是：</p><ul><li>如果操作数是除了 <code>bool</code>、<code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code> 之外的、比 <code>int</code> 更小的整数类型，如果 <code>int</code> 能容纳操作数的值，那么将操作数转换为 <code>int</code> 类型。否则，将操作数转换为 <code>unsigned int</code> 类型。（例如，<code>char</code> 和 <code>short</code> 类型会被提升为 <code>int</code> 类型）</li><li>如果操作数是 <code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code> 类型之一，按照下面的顺序：<code>int</code>、<code>unsigned int</code>、<code>long int</code>、<code>unsigned long int</code>，<code>long long int</code>、<code>unsigned long long int</code>。选择第一个值范围能够容纳的。将操作数转换为这个类型。</li><li>如果操作数是 <code>bool</code> 类型，那么将操作数转换到 <code>int</code> 类型，<code>false</code> 转换为 <code>0</code>，<code>true</code> 转换为 <code>1</code>。</li></ul><h3 id="整数转换" tabindex="-1"><a class="header-anchor" href="#整数转换"><span>整数转换</span></a></h3><p>在<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>之外，整数还有一些转换情况。</p><ul><li>如果目标类型是 <code>bool</code> 类型，那么如果操作数是 <code>0</code>，那么结果是 <code>false</code>，否则结果是 <code>true</code>。</li><li>如果源类型是 <code>bool</code> 类型，那么如果操作数是 <code>false</code>，那么结果是 <code>0</code>，如果操作数是 <code>true</code> 结果是 <code>1</code>。</li></ul><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b 的值是 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c 的值是 true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是 1，42 转换为 true，然后 true 转换为 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述情况之外，转换结果的值是，在目标类型范围内，源值对2^N取模的唯一值，其中 N 是目标类型的位宽。读者可以将这个规则理解为，在数学意义上的如下计算：</p><p><code>Result = Mod(Source - TargetMin, 2^N) + TargetMin</code></p><p>其中，<code>Mod</code>是取余（模运算），<code>Source</code>是源值，<code>TargetMin</code> 是目标类型的最小值，<code>N</code> 是目标类型的位宽。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从 int 类型的 256 转换到 unsigned char</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 unsigned char 位宽为8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 256 对 256 取模是 0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a 的值是 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从 int 类型的 -1 转换到 unsigned long long</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 unsigned long long 位宽为64</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -1 对 2^64 取模是 18446744073709551615</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b 的值是 18446744073709551615</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从 int 类型的 144 转换到 signed char</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 signed char 位宽为8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 144 对 256 取模，signed char 的范围是 -128 到 127，结果是 -112</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// c 的值是 -112</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">signed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 144</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="浮点类型" tabindex="-1"><a class="header-anchor" href="#浮点类型"><span>浮点类型</span></a></h2>`,13),_=a('<h3 id="标准浮点类型" tabindex="-1"><a class="header-anchor" href="#标准浮点类型"><span>标准浮点类型</span></a></h3><p>C++ 中默认提供的浮点类型包括：</p><table><thead><tr><th>类型</th><th>含义</th><th>字面量形式</th><th>类型位宽</th></tr></thead><tbody><tr><td><code>float</code></td><td>单精度浮点数，IEEE-754 binary32 浮点数</td><td><code>1.0f</code>，后缀<code>f</code></td><td>32</td></tr><tr><td><code>double</code></td><td>双精度浮点数，IEEE-754 binary64 浮点数</td><td><code>1.0</code>，没有后缀</td><td>64</td></tr><tr><td><code>long double</code></td><td>扩展精度浮点数</td><td><code>1.0l</code>，后缀<code>l</code></td><td>实现定义</td></tr></tbody></table><p>这些浮点数的行为基本上由 IEEE-754 标准所规定。其中，<code>float</code> 有 1 个符号位、8 个指数位和 23 个尾数位，<code>double</code> 有 1 个符号位、11 个指数位和 52 个尾数位，<code>long double</code> 的位数是实现定义的，如果实现为 x86 上实现的 IEEE-754 binary64 扩展模式，那么它的位数可能是 1 个符号位、15 个指数位和 64 个尾数位。</p>',4),m={class:"hint-container info"},D=a('<p class="hint-container-title">浮点数的表示</p><p>浮点数根据 IEEE-754 有确定的表示形式。例如，<code>3.14f</code> 的值表示是 <code>0 10000000 1001000 11110101 11000011</code>，其中第一位是符号位，接下来的8位是指数，最后的23位是尾数。</p><p>浮点数的表示可以简单地理解成科学计数法的形式，其中指数部分是以 2 为底的指数，尾数部分是二进制小数（二进制 0.1 表示十进制 0.5，二进制 0.11 表示十进制 0.75，二进制 10.101 表示十进制 2.625）。科学记数法中，1e2 和 10e1 是等价的，因此，IEEE-754 规定，尾数部分的二进制小数总会标准化到 <code>1.xxx</code> 的形式；并且由于尾数第一位总是 <code>1</code>，所以省略不存储。指数部分中，IEEE-754 规定，<code>01111111</code> 表示指数为 0，<code>10000000</code> 表示指数为 1，<code>10000001</code> 表示指数为 2，可以理解成一个 0 值与常规不同的 8 位无符号整数。</p><p>因此，我们反推上述的 <code>3.14f</code> 的值表示，它表示的是 + 1.10010001111010111000011 * 2，即 3.1400001049041748046875。读者会发现这是个近似数，毕竟有效位数有限，在进制转换时，经常会有精度损失。</p><p>不过，如果我们考虑 + 1.10010001111010111000010 * 2，也即把最后一位从 1 改成 0，即 3.139999866485595703125，可以发现它和十进制 3.14 的差距比上面的结果更大，也即是说，上面的表示是最接近十进制 3.14 的浮点数。这不是巧合，实现按照规定会将十进制浮点数字面量转换到最接近的 IEEE-754 浮点数。</p><p>有心的读者可能会意识到，假设某个十进制 A 转换到浮点数后，得到的是 IEEE-754 规定的浮点数 B，如果我们再利用输出函数（例如前面提到的<code>std::println</code>）输出 B 会得到什么呢？在现实中，一个浮点数的默认输出常常是其唯一最短形式的十进制小数表示，也即上面的 <code>0 10000000 1001000 11110101 11000011</code> 一定输出为 3.14，而 <code>0 10000000 1001000 11110101 11000010</code> 一定输出为 3.1399999，并且这一转换是可逆的，也即 <code>3.1399999f</code> 一定转换到 <code>0 10000000 1001000 11110101 11000010</code>。浮点数输入输出会计算出到无歧义的最短十进制小数表示，这是 IEEE-754 标准的要求。简单的来说，字面上有多个十进制小数都可以转换到同一个浮点数，但是浮点数转换到十进制小数时，只有一种最短表示，且这一最短表示一定转换成对应的浮点数。</p>',6),B=a('<h3 id="扩展浮点类型" tabindex="-1"><a class="header-anchor" href="#扩展浮点类型"><span>扩展浮点类型</span></a></h3><p>实现可能支持 ISO 60559 规定的扩展浮点类型，这些类型包括：</p><table><thead><tr><th>类型</th><th>ISO 60559 名称</th><th>类型位宽</th><th>指数位宽</th><th>尾数位宽</th></tr></thead><tbody><tr><td><code>std::float16_t</code></td><td>binary16</td><td>16</td><td>5</td><td>10</td></tr><tr><td><code>std::float32_t</code></td><td>binary32</td><td>32</td><td>8</td><td>23</td></tr><tr><td><code>std::float64_t</code></td><td>binary64</td><td>64</td><td>11</td><td>52</td></tr><tr><td><code>std::float128_t</code></td><td>binary128</td><td>128</td><td>15</td><td>112</td></tr><tr><td><code>std::bfloat16_t</code></td><td></td><td>16</td><td>8</td><td>7</td></tr></tbody></table><h3 id="浮点计算" tabindex="-1"><a class="header-anchor" href="#浮点计算"><span>浮点计算</span></a></h3>',4),f=s("code",null,"%",-1),C=s("code",null,"std::partial_ordering",-1),x=a(`<p>简单的来看，浮点数和整数具有的运算基本相同，但是和位运算相关的部分则不适用于浮点数。</p><h3 id="特殊浮点值" tabindex="-1"><a class="header-anchor" href="#特殊浮点值"><span>特殊浮点值</span></a></h3><p>浮点数有一些特殊的值，它们是：正零(+0)、负零(-0)、正无穷(+∞)、负无穷(-∞)、qNaN，sNaN。</p><p>正零的值表示为 <code>0 00000000 00000000000000000000000</code>，负零的值表示为 <code>1 00000000 00000000000000000000000</code>。</p><p>正无穷的值表示为 <code>0 11111111 00000000000000000000000</code>，负无穷的值表示为 <code>1 11111111 00000000000000000000000</code>。</p><p>NaN是Not a Number，意思是不是一个数，当然这也是一种浮点数，而非“不是数”。qNaN是quiet NaN，sNaN是signaling NaN。qNaN 是静默 NaN，而 sNaN 是信号 NaN。NaN 的值表示为 <code>0 11111111 1xxxxxx xxxxxxxx xxxxxxxx</code>，其中指数部分全为1，尾数部分不全为0（注意全为0时这就是正无穷了）。qNaN 的尾数部分（除了那个必须为1的位）最高位为1，而 sNaN 的对应位为0。sNaN 具有一些实现上的作用，例如：</p><ul><li>把内存填满 sNaN，可以检测内存的初始化情况。</li><li>标记溢出的情况</li><li>标记计算结果可能具有更高精度</li><li>标记复数</li></ul><p>这些特殊值在计算和比较的时候具有特殊规则（下面使用 ±0 表示 +0 或 -0，±∞ 表示 +∞ 或 -∞）。</p><p>对于加性表达式和乘性表达式，有以下规则：</p><ul><li>任意浮点数（包括NaN）和 NaN 进行计算，结果是 NaN</li><li>非特殊浮点数除以 ±0 结果是 ±∞（符号与正常除法相同）</li><li>非特殊浮点数计算的结果如果溢出了浮点数范围，则上溢出的结果是 +∞，下溢出的结果是 -∞</li><li>±0 / ±0 结果是 NaN</li><li>±∞ / ±∞ 结果是 NaN</li><li>±0 * ±∞ 结果是 NaN</li><li>+∞ + -∞ 和 +∞ + -∞ 结果是 NaN</li><li>+∞ + +∞ 结果是 +∞，-∞ + -∞ 结果是 -∞</li><li>+∞ - +∞ 结果是 NaN，-∞ - -∞ 结果是 NaN</li></ul><p>对于关系表达式，有以下规则：</p><ul><li>+0 和 -0 相等</li><li>+∞ 和 +∞ 相等， -∞ 和 -∞ 相等</li><li>+∞ 大于任意非特殊浮点数，-∞ 小于任意非特殊浮点数</li><li>任意浮点数（包括NaN）和 NaN 进行任意比较，结果是 <code>false</code>。 <ul><li>对于三路比较（<code>&lt;=&gt;</code>），得到的结果是 <code>std::partial_ordering::unordered</code>。</li></ul></li></ul><h3 id="浮点舍入" tabindex="-1"><a class="header-anchor" href="#浮点舍入"><span>浮点舍入</span></a></h3><p>浮点数的计算可能会有舍入，这是因为浮点数的表示是有限的，而实数是无限的。IEEE-754 标准规定了浮点数的计算规则，每一次表达式求值都可能会按照这一规则发生舍入。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，<code>1.01 * 3</code> 得到的结果并不是准确的 <code>3.03</code>，而是一个接近于 <code>3.0300000000000002</code> 的值。因此，<code>a</code> 的值可能并不是 <code>0</code>，而是一个很小的值（大约 <code>4.440892098500626e-16</code>）。</p><div class="hint-container info"><p class="hint-container-title">精度保证</p><p>C++ 本身并没有对浮点精度做任何保证。在上面的例子中，<code>a</code> 的值也可能被初始化为 <code>0</code>。C++ 允许编译器对浮点数计算做出非常激进的优化，将字面量加减乘除的计算过程认为是无限精度，并只在最终结果上做舍入。此外，现实的处理器存在融合乘法和加法的指令，这种指令可以在计算先乘后加的表达式时保证结果，不会由于多余的一次舍入产生精度问题。因此，上面的例子中，<code>a</code> 的值可能是 <code>0</code>，也可能是一个很小的值，这取决于编译器的优化策略和目标平台的浮点数计算能力。</p></div><p>在处理浮点数时，凡是进行了会损失精度的计算（包括加减乘除等），都可能会有类似的情况，因此，在进行浮点数比较时，应该使用一个误差范围，而不是直接比较两个浮点数的值，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import std;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> double_equal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 误差范围为 1e-9</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">e-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">e-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a = 0 results {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">double_equal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面程序的输出应当是 <code>a = 0 results true</code>。</p><h3 id="浮点转换" tabindex="-1"><a class="header-anchor" href="#浮点转换"><span>浮点转换</span></a></h3><p>在前面提到的，浮点数的计算中，如果操作数的类型不同，那么会按照以下规则进行转换：</p><ul><li>如果另一个操作数不是浮点数，那么将那个非浮点数的操作数转换为相同的浮点数类型。 <ul><li>对于符合 IEEE-754 标准的浮点数，这一转换会转换到最近的浮点数。</li></ul></li><li>如果另一个操作数是浮点数，但是类型不同，那么将较小的浮点数转换为较大的浮点数。 <ul><li>例如，<code>float</code> 和 <code>double</code> 参与计算时，<code>float</code> 会转换为 <code>double</code>。</li></ul></li></ul><p>此外，使用浮点类型可以初始化整数类型，这时候浮点数会被截断为整数，即舍弃小数部分，而不是四舍五入。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的值是 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b 的值是 3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> conversion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> conversion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c 的值是 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25),N=a('<p>使用整数类型也可以初始化浮点数类型，这时候整数会被转换为浮点数，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // d 的值是 42.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，如果转换不能保证精度，那么实现可以选择向上或者向下舍入；对于 IEEE-754 标准的浮点数，这种转换会转换到最近的浮点数。</p>',3),z=a('<h2 id="一般算术转换" tabindex="-1"><a class="header-anchor" href="#一般算术转换"><span>一般算术转换</span></a></h2><p>在目前介绍到的内容中，出现了多种形式的转换，包括<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>、<a href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2">整数转换</a>、<a href="#%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2">浮点转换</a>。</p><p>现在，我们来综合地介绍一下。在需要操作数是算术类型的表达式中，会进行一些形式相似的转换，这种转换称为<strong>一般算术转换</strong>。</p><p>对于算术类型，下列的表达式会先对操作数进行一般算术转换：</p>',4),I=a('<h3 id="转换等级" tabindex="-1"><a class="header-anchor" href="#转换等级"><span>转换等级</span></a></h3><p>在一般算术转换中，整数转换遵循如下的整数转换等级：</p><ul><li>有符号整数类型的等级高于任意位宽更小的有符号整数类型（例如，<code>std::int32_t</code> 高于 <code>std::int16_t</code>）</li><li>下列类型的等级依次递减 <ul><li><code>long long int</code></li><li><code>long int</code></li><li><code>int</code></li><li><code>short int</code></li><li><code>signed char</code></li></ul></li><li>任一无符号整数类型的等级，等于对应的有符号整数类型的等级（例如，<code>std::uint32_t</code> 的等级等于 <code>std::int32_t</code> 的等级）</li><li><code>bool</code> 类型的等级低于任何标准整数类型</li><li><code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code> 的等级等于其基础类型的等级（例如，<code>char8_t</code> 的等级等于 <code>unsigned char</code> 的等级，<code>char16_t</code> 的等级等于 <code>std::uint_least16_t</code> 的等级）</li><li>扩展整数类型的等级由实现定义，但仍遵循上述规则（例如，如果 <code>std::int_fast16_t</code> 的位宽高于 <code>short int</code>，其等级也一定高于 <code>short int</code>）</li></ul><p>在一般算术转换中，浮点数转换遵循如下的浮点转换等级：</p><ul><li>如果某个浮点数类型的所有值是是另一个类型的所有值的子集，那么这个浮点数类型的等级低于另一个浮点数类型的等级 <ul><li><code>long double</code> 的等级高于 <code>double</code> 的等级，<code>double</code> 的等级高于 <code>float</code> 的等级</li></ul></li><li>具有相同值集合的扩展浮点数类型的等级相等 <ul><li>与基础整数类型值集合相同的扩展浮点数类型的等级相等</li></ul></li></ul><h3 id="一般算术转换-1" tabindex="-1"><a class="header-anchor" href="#一般算术转换-1"><span>一般算术转换</span></a></h3><p>一般算术转换的规则如下：</p><ul><li>如果任一操作数是浮点数类型： <ul><li>如果两个操作数的类型相同，不需要转换</li><li>否则，如果其中一个操作数的类型是非浮点数类型，将这个操作数转换到与另一个操作数相同的浮点数类型</li><li>否则，如果两个操作数的类型不同，将较小的浮点数转换为两个操作数中，转换等级较高的浮点数类型</li></ul></li><li>否则，每个操作数会转换到一个公共类型。此时，每个操作数都会发生<a href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87">整数提升</a>。 <ul><li>如果提升后两个操作数的类型相同，那么不需要转换</li><li>否则，如果提升后两个操作数都是有符号整数类型，或者都是无符号整数类型，那么将较小的操作数转换为较大的操作数</li><li>否则，假设提升后操作数类型中，无符号的类型为U，有符号的类型为S <ul><li>如果U的转换等级高于S，那么将操作数都转换为U</li><li>否则，如果S的转换等级高于U，那么将操作数都转换为S</li><li>否则，将操作数都转换为S的无符号版本</li></ul></li></ul></li></ul><p>上面这样一条一条的规则显然只适合于考试和编译器开发者，如果需要日常开发中天天想着这个规则，显然是不现实的。为了方便理解，这里对这个规则做出一个简略的总结：</p><ol><li>将整数变成浮点</li><li>将小于<code>int</code>的类型变成<code>int</code></li><li>将扩展类型变成标准类型</li><li>将较小的类型变成较大的类型</li><li>将一样大的有符号类型变成无符号类型。</li></ol><p>举例而言：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 没有操作数是浮点数</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 整数提升后，类型分别是 `int` 和 `unsigned int`，两者转换等级仍然相同</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 转换为 `int` 的无符号版本，结果是 `unsigned int` 类型</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b; </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 有一个操作数是浮点数</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 `int` 转换为 `float`，结果是 `float` 类型</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的转换规则仍然是一定程度的简化，涉及值类别转换和枚举类型的部分，会在后续章节中介绍。</p><div class="hint-container info"><p class="hint-container-title">为什么？</p><p>一般算术转换的规则是对现实的概括和妥协。</p><p>在常见的平台上，浮点和整数是通过两套不同的电路处理的，这一现实在 C++ 语言上体现为浮点和整数仿佛是两个冤家，在一个浮点数加入了聚会之后，整个聚会就被迫变成了浮点数的聚会，这时候那些位运算就被请出了门。如果非要让浮点数加入整数的聚会，我们就不得不费劲地把浮点数塞进整数的衣服里。</p><p>这里这种“处理整数的电路”，它提供的很多功能要求数据至少有 <code>int</code> 的尺寸，并且参与处理的两个数据也要求大小相同。正因如此，一般算术转换中会将小于 <code>int</code> 的整数类型转换为 <code>int</code>，并且必须找到一个公共的类型来进行运算。</p><p>基础算术类型是对平台这种特性的一种抽象，它将硬件支持最佳的几种数据表示抽象为 <code>int</code>、<code>long int</code> 这些基础类型。然后再提供扩展类型，以适应更多的需求。</p><p>事实上，这种先抽象成基础类型，再抽象成扩展类型的二次抽象是一种过于复杂的历史遗留。程序员仍然需要浪费心智查看硬件手册，以理解 <code>int</code> 和 <code>char</code> 究竟是什么东西。已经进行了尝试的读者也会发现，几乎所有情况下，<code>std::int32_t</code> 就是 <code>int</code>，<code>std::int64_t</code> 就是 <code>long long int</code>，这层抽象在实际中几乎没有产生任何价值。于是，更现代的设计直接将扩展类型作为基础类型，具体如何选择表示和指令让编译器来分析。笔者也推荐读者直接使用扩展类型，而不要费神纠结基础类型的性质。</p></div>',14);function U(T,L){const d=n("RouteLink"),l=n("Binary32");return c(),o("div",null,[r,s("p",null,[i("前面提到过了"),t(d,{to:"/zh/03-types/01-types.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"},{default:e(()=>[i("类型别名")]),_:1}),i("，类型别名不能将这样多个关键字组成的类型拆开，例如：")]),k,s("p",null,[i("整数类型的运算基本与"),t(d,{to:"/zh/02-program-structure/expression.html"},{default:e(()=>[i("表达式")]),_:1}),i("章节中介绍的一致，除了由于位宽和 "),g,i(" 不同，结果的范围有所不同。")]),s("p",null,[i("在前面"),t(d,{to:"/zh/02-program-structure/expression.html#%E5%8A%A0%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%B9%98%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("加性表达式和乘性表达式")]),_:1}),i("的章节中提到过，如果 "),E,i(" 类型表达式的计算结果超出了 "),u,i(" 类型的范围，那么结果是未定义的。这种性质对其他有符号整数类型也是适用的。")]),y,s("p",null,[i("之前的章节中介绍过，在计算 "),t(d,{to:"/zh/02-program-structure/expression.html#%E4%B9%98%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("乘性表达式")]),_:1}),i(" 时，如果操作数是 "),A,i(" 或者 "),b,i(" 时，会转换为 "),F,i(" 类型。这种转换称为整数提升。")]),v,s("p",null,[i("在"),t(d,{to:"/zh/01-hello-world/literals.html#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F"},{default:e(()=>[i("浮点数字面量")]),_:1}),i("一节中，已经简要概述了浮点类型的字面量，这里我们详细介绍浮点类型。")]),_,s("div",m,[D,t(l)]),B,s("p",null,[i("浮点数类型不能进行全部的前面"),t(d,{to:"/zh/02-program-structure/expression.html"},{default:e(()=>[i("表达式")]),_:1}),i("所介绍的运算。浮点数的计算是按照 IEEE-754 标准进行的，这主要包括：")]),s("ul",null,[s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E5%90%8E%E7%BC%80%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("后缀自增")]),_:1}),i("和"),t(d,{to:"/zh/02-program-structure/expression.html#%E5%89%8D%E7%BC%80%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("前缀自增")]),_:1}),i("：将操作数浮点数的值增加1。")]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E5%90%8E%E7%BC%80%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("后缀自减")]),_:1}),i("和"),t(d,{to:"/zh/02-program-structure/expression.html#%E5%89%8D%E7%BC%80%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("前缀自减")]),_:1}),i("：将操作数浮点数的值减少1。")]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E6%AD%A3%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("正运算符")]),_:1}),i("：表达式的值与操作数相同。")]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E8%B4%9F%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("负运算符")]),_:1}),i("：将操作数的符号取反。")]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E5%8A%A0%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%B9%98%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("加性表达式和乘性表达式")]),_:1}),i("：如同数学计算，表达式的值是将操作数的值进行计算。由于浮点数存在精度，因此在计算时可能会有舍入。浮点数不能进行模运算（"),f,i("）。")]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("关系表达式")]),_:1}),i("：如同数学比较。不过浮点数有一些特殊值，这在后面进行介绍。三路比较时，浮点数的比较结果是 "),C,i(" 类型，会出现一个特殊的“无顺序”结果。")]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("赋值表达式")]),_:1}),i("：如同整数的赋值。")])]),x,s("p",null,[i("如果截断之后，浮点数的值超出了整数类型的范围，这时行为是"),t(d,{to:"/zh/02-program-structure/expression.html#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"},{default:e(()=>[i("未定义行为")]),_:1}),i("。")]),N,s("p",null,[i("如果转换之后，整数的值超出了浮点数类型的范围，这时行为是"),t(d,{to:"/zh/02-program-structure/expression.html#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"},{default:e(()=>[i("未定义行为")]),_:1}),i("。")]),z,s("ul",null,[s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E6%AD%A3%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("正运算符")]),_:1})]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E8%B4%9F%E8%BF%90%E7%AE%97%E7%AC%A6"},{default:e(()=>[i("负运算符")]),_:1})]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D"},{default:e(()=>[i("按位取反")]),_:1})]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E5%8A%A0%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%B9%98%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("加性表达式和乘性表达式")]),_:1})]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E7%A7%BB%E4%BD%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("移位表达式")]),_:1})]),s("li",null,[t(d,{to:"/zh/02-program-structure/expression.html#%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:e(()=>[i("按位逻辑表达式")]),_:1})])]),I])}const w=h(p,[["render",U],["__file","arithmetic-types.html.vue"]]),R=JSON.parse('{"path":"/zh/03-types/arithmetic-types.html","title":"3.2 算术类型","lang":"zh-CN","frontmatter":{"title":"3.2 算术类型"},"headers":[{"level":2,"title":"整数类型","slug":"整数类型","link":"#整数类型","children":[{"level":3,"title":"一些实现的类型大小","slug":"一些实现的类型大小","link":"#一些实现的类型大小","children":[]},{"level":3,"title":"扩展整数类型","slug":"扩展整数类型","link":"#扩展整数类型","children":[]},{"level":3,"title":"整数类型的运算","slug":"整数类型的运算","link":"#整数类型的运算","children":[]},{"level":3,"title":"整数提升","slug":"整数提升","link":"#整数提升","children":[]},{"level":3,"title":"整数转换","slug":"整数转换","link":"#整数转换","children":[]}]},{"level":2,"title":"浮点类型","slug":"浮点类型","link":"#浮点类型","children":[{"level":3,"title":"标准浮点类型","slug":"标准浮点类型","link":"#标准浮点类型","children":[]},{"level":3,"title":"扩展浮点类型","slug":"扩展浮点类型","link":"#扩展浮点类型","children":[]},{"level":3,"title":"浮点计算","slug":"浮点计算","link":"#浮点计算","children":[]},{"level":3,"title":"特殊浮点值","slug":"特殊浮点值","link":"#特殊浮点值","children":[]},{"level":3,"title":"浮点舍入","slug":"浮点舍入","link":"#浮点舍入","children":[]},{"level":3,"title":"浮点转换","slug":"浮点转换","link":"#浮点转换","children":[]}]},{"level":2,"title":"一般算术转换","slug":"一般算术转换","link":"#一般算术转换","children":[{"level":3,"title":"转换等级","slug":"转换等级","link":"#转换等级","children":[]},{"level":3,"title":"一般算术转换","slug":"一般算术转换-1","link":"#一般算术转换-1","children":[]}]}],"git":{"createdTime":1719943204000,"updatedTime":1727960786000,"contributors":[{"name":"dynilath","email":"dynilath@qq.com","commits":20}]},"readingTime":{"minutes":25.65,"words":7696},"filePathRelative":"zh/03-types/arithmetic-types.md","localizedDate":"2024年7月2日"}');export{w as comp,R as data};
