import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as e,c as h,d as s,e as i,a as t,w as p,b as d}from"./app-DNTRvR-x.js";const k={},r=s("p",null,[s("strong",null,"值类别"),i("（value category）在 C++ 是一个用来描述表达式性质的概念。注意，值类别并不是表达式的类型，放在类型一章的此处，是因为这个概念对于对接下来类型的理解是必要的。")],-1),c=d(`<p>我们简要地复习一下：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里声明了两个整数类型的对象 a 和 b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a 的名字可以组成一个基础表达式</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个表达式指代 a 这个对象，因此可以被赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用括号包围的表达式与内部表达式的性质相同</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于 a 指代一个对象，因此 (a) 也指代这个对象，可以被赋值 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 赋值表达式作为整体，指代 = 符号左边的对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此可以被赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果条件表达式的第二个和第三个操作数都指代对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 并且类型相同，那么条件表达式的结果也指代对象，可以被赋值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 那么条件表达式的结果也指代对象，可以被赋值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里 condition() 是假设的一个返回 bool 类型的函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line highlighted error"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误，a 和 c 的类型不同，此时条件表达式的结果不指代对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在表达式一节中没有提到的是，如果逗号表达式的最后一个操作数指代对象，那么逗号表达式的结果也指代对象，可以被赋值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 左边这个逗号表达式的结果指代对象 b</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此可以被赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="值类别的分类" tabindex="-1"><a class="header-anchor" href="#值类别的分类"><span>值类别的分类</span></a></h2><p>在 C++ 中，任何表达式属于以下三种值类别之一：</p><ul><li><strong>左值</strong>（lvalue）</li><li><strong>纯右值</strong>（prvalue）</li><li><strong>将亡值</strong>（xvalue）</li></ul><p>顾名思义，左值就是可以出现在赋值运算符左边的值，而右值则是只能出现在赋值运算符右边的值。这是从 C 语言，甚至更古老的 CPL 中继承发展下来的概念。</p><p>将亡值则是 C++ 中引入的概念——在一些表达式中会产生了一个临时对象，这样的对象的生命周期往往在表达式结束后就会结束。为了区分这样的对象，C++ 引入了将亡值这个概念。</p><p>很容易理解到，这里提到的左值，就是前文所述的“指代对象的表达式”，而纯右值则是“不指代对象的表达式”。将亡值虽然“指代对象”，但是这个对象的生命周期往往很短，因此被单独列出。</p><p>目前，还没有介绍到会产生将亡值的表达式，这里先介绍表达式左值和纯右值的情形。</p><h3 id="左值表达式" tabindex="-1"><a class="header-anchor" href="#左值表达式"><span>左值表达式</span></a></h3><p>下列表达式是左值表达式：</p><ul><li>如 <code>a</code>、<code>condtion</code> 这样，指代对象、函数的标识符组成的基本表达式 <ul><li>注意：虽然类型有 <code>const</code> 限定的对象不能被修改，但是 <code>const</code> 限定的对象的名字仍然是左值</li></ul></li><li>如 <code>a = 1</code>、<code>a += b</code> 这样的赋值、复合赋值表达式</li><li>如 <code>++a</code>、<code>--a</code> 这样的前置自增、前置自减表达式</li><li>第二和第三操作数是相同类型的左值时的条件表达式</li><li>最后一个操作数是左值的逗号表达式</li></ul><h3 id="纯右值表达式" tabindex="-1"><a class="header-anchor" href="#纯右值表达式"><span>纯右值表达式</span></a></h3><p>下列表达式是右值表达式：</p><ul><li>如 <code>1</code>、<code>true</code> 这样的字面量组成的基本表达式</li><li>如 <code>a++</code>、<code>a--</code> 这样的后置自增、后置自减表达式</li><li>如 <code>a + b</code>、<code>a * b</code> 这样的算术表达式</li><li>如 <code>a == b</code>、<code>a &lt; b</code> 这样的关系表达式</li><li>如 <code>a &amp;&amp; b</code>、<code>a || b</code> 这样的逻辑表达式</li><li>第二第三操作数类型不同，或者有一个不是左值的条件表达式 <ul><li>形如 <code>true ? a : 1</code> 这样，总是选择左值那个操作数的条件表达式依然是纯右值</li></ul></li><li>最后一个操作数是纯右值的逗号表达式</li></ul><h2 id="泛左值和右值" tabindex="-1"><a class="header-anchor" href="#泛左值和右值"><span>泛左值和右值</span></a></h2><p>除了上述的左值、纯右值、将亡值之外，C++ 还引入了泛左值和右值的概念。</p><p>有的时候，程序员需要通过一个左值的处理方式来处理将亡值，这时，将亡值和左值一起分类为<strong>泛左值</strong>。</p><p>有的时候，程序员需要把将亡值当做右值来处理，这时，将亡值和纯右值一起分类为<strong>右值</strong>。</p><p>这里提到的处理方式目前还没有介绍，但在后面的章节中，读者会看到这两种处理方式。</p>`,22);function o(g,E){const a=l("RouteLink");return e(),h("div",null,[r,s("p",null,[i("在"),t(a,{to:"/zh/02-program-structure/expression.html#%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B5%8B%E5%80%BC"},{default:p(()=>[i("表达式")]),_:1}),i("一节中，我们曾经提到过“能不能赋值”这样的问题。其中提到，如果表达式指代某个对象，那么这个表达式是能够被赋值的。")]),c])}const v=n(k,[["render",o],["__file","value-category.html.vue"]]),m=JSON.parse('{"path":"/zh/03-types/value-category.html","title":"3.4 值类别","lang":"zh-CN","frontmatter":{"title":"3.4 值类别"},"headers":[{"level":2,"title":"值类别的分类","slug":"值类别的分类","link":"#值类别的分类","children":[{"level":3,"title":"左值表达式","slug":"左值表达式","link":"#左值表达式","children":[]},{"level":3,"title":"纯右值表达式","slug":"纯右值表达式","link":"#纯右值表达式","children":[]}]},{"level":2,"title":"泛左值和右值","slug":"泛左值和右值","link":"#泛左值和右值","children":[]}],"git":{"createdTime":1722014570000,"updatedTime":1727960786000,"contributors":[{"name":"dynilath","email":"dynilath@qq.com","commits":5}]},"readingTime":{"minutes":4.12,"words":1237},"filePathRelative":"zh/03-types/value-category.md","localizedDate":"2024年7月26日"}');export{v as comp,m as data};
