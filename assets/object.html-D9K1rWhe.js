import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as p,c as k,d as s,e as i,a as e,w as n,b as l}from"./app-DNTRvR-x.js";const d={},r=l('<h2 id="对象的性质" tabindex="-1"><a class="header-anchor" href="#对象的性质"><span>对象的性质</span></a></h2><p>C++ 中，对象有以下性质：</p><ul><li><strong>大小</strong>：对象在内存中占据一定的空间，这个空间的大小就是对象的大小。</li><li><strong>对齐要求</strong>：对象在内存中的存储位置有一定的要求，类似于大号的箱子不能放在小号的格子里，这个要求就是对齐要求。</li><li><strong>存储期</strong>：对象占用空间的一段时间，这个时间段称为对象的存储期。</li><li><strong>生存期</strong>：对象在占用空间里有效的一段时间，这个时间段称为对象的生存期。</li><li><strong>值</strong>：对象的值是对象存储的数据，是对象的内容。</li><li><strong>类型</strong>：对象的类型决定了对象的值的形式，以及对象可以进行的操作。</li></ul><p>对象不一定具有名字。例如，我们之前提过的没有名称的函数参数，表达式的值等。</p><p>类型作为对象的性质，除了规定了对象的值的形式、对象可以进行的操作以外，也规定了对象的大小和对齐。也就是说，相同类型的对象，其大小和对齐要求一定是相同的。</p><h3 id="不完整类型" tabindex="-1"><a class="header-anchor" href="#不完整类型"><span>不完整类型</span></a></h3><p>目前，我们了解到 <code>void</code> 类型是没有值的，它也是一个不完整类型。不完整类型没有大小，也没有对齐要求。因此，我们不能使用 <code>sizeof</code> 和 <code>alignof</code> 运算符来获取不完整类型的大小和对齐要求。当然，也不能声明一个不完整类型的对象。</p><h2 id="sizeof-表达式" tabindex="-1"><a class="header-anchor" href="#sizeof-表达式"><span><code>sizeof</code> 表达式</span></a></h2><p>在 C++ 中，我们可以使用 <code>sizeof</code> 运算符来获取对象的大小。<code>sizeof</code> 表达式的形式是：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type_id)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sizeof expression</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',12),c=s("code",null,"sizeof",-1),g=s("code",null,"type_id",-1),o=s("code",null,"expression",-1),E=s("code",null,"sizeof",-1),u=s("code",null,"size_t",-1),y=s("code",null,"size_t",-1),v=l(`<div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_of_a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sizeof a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取对象 a 的大小</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_of_int </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取 int 类型的大小</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，<code>size_of_a</code> 和 <code>size_of_int</code> 都是 <code>size_t</code> 类型的值，分别表示对象 <code>a</code> 和 <code>int</code> 类型的大小。当然，由于 <code>a</code> 的类型是 <code>int</code>，所以这两个值是相等的。</p><p>C++ 规定 <code>sizeof(char)</code> 的值为 1，其他类型的大小则由实现决定。但这并不是实现随便拍脑门决定，在后面我们会详细介绍各种基础类型。</p><div class="hint-container tip"><p class="hint-container-title">sizeof 用法的统一</p><p>这里 <code>sizeof</code> 表达形式有两种，记忆使用时会带来一些不便。不妨考虑这样： 一元表达式可以是括号 <code>()</code> 括起来的表达式，也即一个基础表达式。那么，可以用 <code>sizeof (expression)</code> 来获取表达式的大小，这样其形式上就和 <code>sizeof (type_id)</code> 一致了。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_of_a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取对象 a 的大小</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_of_int </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取 int 类型的大小</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就免去了程序员耗费心智区分两种形式的麻烦。但是当看到没有括号的 <code>sizeof</code> 表达式时，也不要忘记其含义。</p></div><p>在 <code>sizeof</code> 表达式计算的时候，作为其组成部分的对象不会被求值。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_of_a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取对象 a 的大小</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时 a 的值仍然是 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，<code>a++</code> 不会被求值，从而其副作用（让 <code>a</code> 增加1）不会发生，<code>a</code> 的值仍然是 1。</p><h2 id="alignof-表达式" tabindex="-1"><a class="header-anchor" href="#alignof-表达式"><span><code>alignof</code> 表达式</span></a></h2><p>在 C++11 中，我们可以使用 <code>alignof</code> 运算符来获取对象的对齐要求。<code>alignof</code> 表达式的形式是：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alignof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type_id)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，<code>alignof</code> 是一个关键字，在这里作为一个运算符。<code>type_id</code> 需要是一个完整类型。</p><p><code>alignof</code> 表达式的值是一个 <code>size_t</code> 类型的值，表示对象的对齐要求。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> align_of_a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> alignof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取 int 类型的对齐要求</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="存储期" tabindex="-1"><a class="header-anchor" href="#存储期"><span>存储期</span></a></h2>`,14),b=l(`<p>这里，需要引入一个新的概念，<strong>块作用域</strong>。块作用域规定了对象在一个块内有效，块结束时，块作用域内的对象就会被销毁。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期结束</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里 a 已经被销毁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>技术性地说，<strong>块作用域</strong>的定义是：</p><ul><li>选择语句、循环语句的边界 <ul><li>作为上述语句的选择体/循环体的语句的边界</li></ul></li><li>复合语句的边界</li></ul><p>组成了一个<strong>块作用域</strong>，这些语句本身在这个块作用域中。具体而言：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 if 之前，进入了 if 语句的块作用域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在这个花括号之前，进入了 if 语句里面的选择体，一个复合语句的块作用域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在这个花括号之后，离开了此复合语句的块作用域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在这个分号之后，离开了 if 语句的块作用域（if 语句的 else 部分对应的选择体）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，命名空间虽然涉及了花括号 <code>{}</code>，但是这不是复合语句，也不会引入块作用域。</p><h3 id="静态存储期" tabindex="-1"><a class="header-anchor" href="#静态存储期"><span>静态存储期</span></a></h3><p>如果声明一个对象，且对象直接处于一个命名空间（包括全局命名空间）内。那么这个对象的存储期是<strong>静态存储期</strong>。静态存储期的对象在程序开始时分配空间，在程序结束时回收。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.cpp 开始</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期是静态存储期</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // a 在这里也是可见的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.cpp 结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，可以在块作用域内部使用 <code>static</code> 关键字来声明一个静态存储期的对象。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期是静态存储期</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里关键字 <code>static</code> 修饰 <code>a</code> 的声明，指定 <code>a</code> 的存储期为静态存储期。注意， <code>static</code> 不是类型的一部分，<code>a</code> 的类型仍然是 <code>int</code>。</p><h3 id="自动存储期" tabindex="-1"><a class="header-anchor" href="#自动存储期"><span>自动存储期</span></a></h3><p>如果声明一个对象，并且对象在是块作用域内（并且没有被<code>static</code>修饰），那么这个对象的存储期是<strong>自动存储期</strong>。自动存储期的对象在被声明时分配空间，在其声明时处于的块作用域结束时回收。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期是自动存储期</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有多层块作用域，那么对象的存储期是其生命时的块作用域。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b 的存储期开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 内层 b 的存储期结束</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 外层 b 的存储期结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在循环语句中，循环体会引入一个块作用域，因此循环体内的对象的存储期仅有一次循环。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // i 的存储期开始</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ![code error] // 错误：a 在这里是不可见的，并且上个循环中的 a 存储期已经结束，这个循环 a 的存储期还没有开始</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a 的存储期结束</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// i 的存储期结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动态存储期和线程存储期" tabindex="-1"><a class="header-anchor" href="#动态存储期和线程存储期"><span>动态存储期和线程存储期</span></a></h3><p>在 C++ 中，还有两种存储期：<strong>动态存储期</strong>和<strong>线程存储期</strong>。目前还没有介绍足够读者理解这两种存储期的概念，因此这两种存储期我们会在后面的章节中详细介绍。</p><h3 id="生存期" tabindex="-1"><a class="header-anchor" href="#生存期"><span>生存期</span></a></h3><div class="hint-container important"><p class="hint-container-title">TODO: 改进描述</p></div><p>对于我们已经提过的 <code>int</code>、<code>char</code>、<code>bool</code>、<code>size_t</code> 这些类型，它们的存储期开始也直接意味着生存期开始、生存期结束也直接意味着存储期结束。因此，对于目前我们已经介绍的类型，存储期和生存期是一致的。</p><p>而对于自定义类型，其生存期和存储期的关系则更为复杂，我们会在后面的章节中详细介绍。</p>`,26);function m(A,D){const a=t("RouteLink");return p(),k("div",null,[s("p",null,[i("在"),e(a,{to:"/zh/02-program-structure/declaration.html"},{default:n(()=>[i("初识声明")]),_:1}),i("中，我们介绍了声明会引入对象。对象占据了内存中的一块空间存储数据。对象的类型决定了对象的大小和存储的数据类型。")]),r,s("p",null,[i("其中，"),c,i(" 是一个关键字，在这里作为一个运算符。"),g,i(" 需要是一个完整类型，"),o,i(" 是"),e(a,{to:"/zh/02-program-structure/expression.html#%E4%B8%80%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:n(()=>[i("一元表达式")]),_:1}),i("。")]),s("p",null,[E,i(" 表达式是一个"),e(a,{to:"/zh/02-program-structure/expression.html#%E4%B8%80%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"},{default:n(()=>[i("一元表达式")]),_:1}),i("，其值是一个 "),u,i(" 类型的值，表示对象的大小。"),y,i(" 是一个无符号的整数类型（不会有负数），其值足以表达当前平台上任意对象的大小。例如：")]),v,s("p",null,[i("在"),e(a,{to:"/zh/02-program-structure/scope.html"},{default:n(()=>[i("初识作用域")]),_:1}),i("中，我们介绍了作用域的概念，作用域决定了对象能否被访问。而对象的存储期和生存期，一定程度上是作用域的一个延伸。")]),b])}const _=h(d,[["render",m],["__file","object.html.vue"]]),z=JSON.parse('{"path":"/zh/02-program-structure/object.html","title":"2.6 对象与存储期","lang":"zh-CN","frontmatter":{"title":"2.6 对象与存储期"},"headers":[{"level":2,"title":"对象的性质","slug":"对象的性质","link":"#对象的性质","children":[{"level":3,"title":"不完整类型","slug":"不完整类型","link":"#不完整类型","children":[]}]},{"level":2,"title":"sizeof 表达式","slug":"sizeof-表达式","link":"#sizeof-表达式","children":[]},{"level":2,"title":"alignof 表达式","slug":"alignof-表达式","link":"#alignof-表达式","children":[]},{"level":2,"title":"存储期","slug":"存储期","link":"#存储期","children":[{"level":3,"title":"静态存储期","slug":"静态存储期","link":"#静态存储期","children":[]},{"level":3,"title":"自动存储期","slug":"自动存储期","link":"#自动存储期","children":[]},{"level":3,"title":"动态存储期和线程存储期","slug":"动态存储期和线程存储期","link":"#动态存储期和线程存储期","children":[]},{"level":3,"title":"生存期","slug":"生存期","link":"#生存期","children":[]}]}],"git":{"createdTime":1719942922000,"updatedTime":1721203013000,"contributors":[{"name":"dynilath","email":"dynilath@qq.com","commits":6}]},"readingTime":{"minutes":7.31,"words":2194},"filePathRelative":"zh/02-program-structure/object.md","localizedDate":"2024年7月2日"}');export{_ as comp,z as data};
