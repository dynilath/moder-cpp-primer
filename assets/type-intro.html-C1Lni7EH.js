import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as h,o as p,c as d,d as e,e as i,a,w as n,b as l}from"./app-DNTRvR-x.js";const k={},r=l('<p>本章将详细介绍 C++ 中的类型，包括基本类型、复合类型、自定义类型等。</p><p>除了对象有类型之外，前面常常提到的“值”也有类型，函数也有类型。</p><h2 id="值表示与对象表示" tabindex="-1"><a class="header-anchor" href="#值表示与对象表示"><span>值表示与对象表示</span></a></h2><p>在 C++ 中，类型是值的集合，以及值上的操作的集合。这里的“值”是指对象的值，而“对象”是指存储在内存中的数据。</p><p>由于一些对技术上的妥协，为了实现更高效更可靠的处理能力，对象占用的内存并不会完全用于表达对象的值，对象占用的内存中会存在一些<strong>填充位</strong>。</p><p>这里，对象占用的内存中的这些字节称为<strong>对象表示</strong>，对象表示中参与表示对象的值的位称呼为<strong>值表示</strong>。</p>',6),c=l(`<div class="hint-container info"><p class="hint-container-title">二进制表示</p><p>在很多时候，人们描述对象会使用“二进制表示”这样的说法。通常而言，这是在用二进制来描述一个对象的值表示。不过，值表示是 C++ 标准中的的术语，在更广泛的场景里，使用“二进制表示”的说法更便于沟通。</p></div><h2 id="类型别名" tabindex="-1"><a class="header-anchor" href="#类型别名"><span>类型别名</span></a></h2><p>类型别名是一个已存在类型的别名。通过类型别名，我们可以为一个类型定义一个新的名字。</p><p>声明类型别名的方式是使用 <code>using</code> 关键字，语法如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alias_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> existing_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，<code>alias_type</code> 是一个新引入的标识符，表示相同类型，<code>existing_type</code> 是已存在的类型的标识符（技术性地说，也能是表示类型的表达式，在这里我们不深入讨论）。</p><p>类型别名可以如同已经存在的类型一般使用，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Integer 是 int 的别名</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Integer a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等价于 int a = 42;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 函数前向声明</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以这样定义，Integer 是 int 的别名意味着 Integer 就是 int 类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此这里的函数定义和前向声明是匹配的</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Integer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Integer</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="旧式类型别名" tabindex="-1"><a class="header-anchor" href="#旧式类型别名"><span>旧式类型别名</span></a></h3><p>在 20 世纪的 C 和 C++ 中，<code>typedef</code> 是声明类型别名的关键字。相较于 <code>using</code> 关键字，<code>typedef</code> 更不直观。</p><p><code>typedef</code> 的语法是：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> declaration</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的 <code>declaration</code> 是一个没有初始化器的声明语句。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer, integer;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果没有这里的 <code>typedef</code>，这会是一个声明语句，并声明了两个 <code>int</code> 类型的对象： <code>Integer</code> 和 <code>integer</code>。由于 <code>typedef</code> 的参与，这个声明的含义就变成了声明了两个 <code>int</code> 类型的类型别名：<code>Integer</code> 和 <code>integer</code>。</p><p><code>typedef</code> 并不一定要出现在最开始，它可以出现在声明的标识符前面的任何位置。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typedef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样也是合法地声明了 <code>Integer</code> 是 <code>int</code> 的别名。</p><p>对于复杂的类型，这种别名声明会相比 <code>using</code> 产生一些麻烦，这在后面的章节中会有所体现。</p><h2 id="auto-推导声明" tabindex="-1"><a class="header-anchor" href="#auto-推导声明"><span><code>auto</code> 推导声明</span></a></h2><p>在声明一个对象时，我们可以使用 <code>auto</code> 关键字来代替声明中的对象类型，指示根据初始化器的类型来推导对象的类型。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于初始化器是 int 字面量 42 类型为 int</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此推导 a 的类型为 int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于初始化器是 a，类型为 int</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此推导 b 的类型为 int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，<code>auto</code>也可以用于函数返回值的类型推导：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doubled_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于 x 是 int 类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此 doubled_x 的返回值类型是 int</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因此 a 的类型是 int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doubled_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于目前的内容而言，读者可能会觉得 <code>auto</code> 的使用并不是很有必要，甚至会觉得 <code>auto</code> 的使用会使代码变得不够清晰。但是在后面的章节中，我们会逐渐看到 <code>auto</code> 的使用能够让复杂的程序变得简洁明了且更易维护。</p><h2 id="decltype-类型推导" tabindex="-1"><a class="header-anchor" href="#decltype-类型推导"><span><code>decltype</code> 类型推导</span></a></h2><p><code>decltype</code> 是一个运算符，用来推导表达式的类型。<code>decltype</code> 的语法是：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">decltype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expression)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，<code>expression</code> 是一个表达式，整个 <code>decltype(expression)</code> 的结果是 <code>expression</code> 的类型，可以用在需要提供类型的语法位置。</p><p><code>decltype</code> 可以如下使用：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">decltype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b 的类型是 int</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如同前面 <code>auto</code> 的例子，我们可以这样使用 <code>decltype</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    decltype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，C++ 中存在一些专门需要进行类型推导的场景，这时 <code>decltype</code> 就会发挥出它最重要的作用。这些场景会在后面的章节中详细介绍。</p>`,34);function g(o,E){const s=h("RouteLink");return p(),d("div",null,[e("p",null,[i("在"),a(s,{to:"/zh/02-program-structure/declaration.html#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1"},{default:n(()=>[i("类型与对象")]),_:1}),i("中，我们已经介绍过，对象的类型决定了对象的值的集合，以及对象上可以进行的操作。")]),r,e("p",null,[i("在前面介绍"),a(s,{to:"/zh/02-program-structure/expression.html"},{default:n(()=>[i("表达式")]),_:1}),i("的章节中，对于位运算，我们提到了“二进制表示”。这里的“二进制表示”是指对象的值表示。")]),c])}const v=t(k,[["render",g],["__file","type-intro.html.vue"]]),b=JSON.parse('{"path":"/zh/03-types/type-intro.html","title":"3.1 类型概述","lang":"zh-CN","frontmatter":{"title":"3.1 类型概述"},"headers":[{"level":2,"title":"值表示与对象表示","slug":"值表示与对象表示","link":"#值表示与对象表示","children":[]},{"level":2,"title":"类型别名","slug":"类型别名","link":"#类型别名","children":[{"level":3,"title":"旧式类型别名","slug":"旧式类型别名","link":"#旧式类型别名","children":[]}]},{"level":2,"title":"auto 推导声明","slug":"auto-推导声明","link":"#auto-推导声明","children":[]},{"level":2,"title":"decltype 类型推导","slug":"decltype-类型推导","link":"#decltype-类型推导","children":[]}],"git":{"createdTime":1706612101000,"updatedTime":1722711329000,"contributors":[{"name":"dynilath","email":"dynilath@qq.com","commits":2}]},"readingTime":{"minutes":4.29,"words":1288},"filePathRelative":"zh/03-types/type-intro.md","localizedDate":"2024年1月30日"}');export{v as comp,b as data};
