---
title:  2.2 初识表达式
---

表达式是组成 C++ 程序的基本元素之一。**表达式**表示一个计算过程，可以用来计算一个值，以及产生其他影响程序状态的副作用。

在编译器处理表达式的时候，换行符如同空格一样，当做空白字符处理。因此，换行符不会影响表达式的语义。

## 基本表达式

基本表达式是表达式的最基本组成部分，通常而言基本表达式是一个整体。基本表达式包括：

这一节作为入门，只介绍一部分的基本表达式。

**字面量** 组成了一个基本表达式，这个基本表达式的值就是字面量的值。例如：
```cpp
42 // 整数字面量 42 组成的基本表达式，值为整数值 42
```

**标识符** 可以是一个基本表达式，它的值是标识符所代表的对象的值。例如：
```cpp
a // 标识符a组成的基本表达式，值为标识符 a 所代表的对象的值
```

**括号包围的表达式** 也是一个基本表达式，它的值是括号内表达式的值。例如：
```cpp
(42) // 括号内的整数字面量 42 组成的基本表达式，值为整数值 42
(a + b) // 括号内的表达式 a + b 组成的基本表达式，值为 a + b 的值
```
在上面这个例子里`(a + b)`是一个基本表达式，但是它里面的表达式却不是基本表达式。那么如何理解基本表达式是一个整体呢？

不妨考虑这样的结构：`(a + b) * c`，这个表达式的值是 `(a + b)` 和 `c` 进行 `*` 运算的结果，而不是 `a + (b * c)` 。这就是基本表达式是一个整体的含义，基本表达式的值只用考虑基本表达式本身，而不用考虑其他组合。

:::info
你可能会觉得，这不就是数学运算的优先级吗？

是的，仅考虑算数运算的话，括号的作用就像数学中一样。但是，C++ 中的表达式不仅仅是算数运算，还有很多其他的表达式，有的看起来完全不像个运算；表达式还有一些数学算式所不具有的性质，这都需要对表达式有一个更直观的理解。

因此，这里采用了表达式结构的形式来解释表达式，而不是数学运算优先级的形式。
:::

## 一元表达式

一元表达式有很多种，这里暂时只介绍其中两种与算数相关的表达式：正运算符和负运算符表达式。其形式为：

- `+ 基本表达式`
- `- 基本表达式` 
- `~ 基本表达式`
- `! 基本表达式`
- `基本表达式`

其中 `+` 表示正运算符，`-` 表示负运算符，`~` 表示按位取反，`!` 表示逻辑非。

:::info
技术性地说，一元表达式形式应当是 `+ 转换表达式`、`- 转换表达式`、`后缀表达式`等。`后缀表达式` 又由`函数调用`、`数组访问`、`基本表达式`等组成。

这里为了方便理解，对一元表达式的形式做出了简化，只介绍了一元表达式的一部分。
:::

### 正运算符

目前我们只考虑 `int`、`bool`、`char` 这三种基本类型的运算。

对于 `int`，正运算符的作用是得到里面的基本表达式的值。例如：
```cpp
+42 // 值为 42
```
注意，`+a`这个表达式虽然值和 `a` 一样，但是 `+a` 不同与 `a`，不再指代 `a` 所代表的对象，而是另一个和 `a` 相同的值。

### 整数提升

对于 `bool` 和 `char` 类型，正运算符会将其转换为 `int` 类型。例如：
```cpp
+true // 值为 1
+false // 值为 0
+'a' // 值为 97
```
这个转换被称为整数提升，类型大小比 `int` 小的整数类型在正运算符、负运算符的表达式中会被提升为 `int` 类型。

后面会介绍到其他的运算符，这种整数提升也会在其他运算符中出现。它们遵循相同的规则，即将类型大小比 `int` 小的整数类型提升为 `int` 类型，然后进行计算。

### 负运算符

负运算符的作用是得到里面的基本表达式的相反数。例如：
```cpp
-42 // 值为 -42
```
负运算符的作用和正运算符类似，同样会进行[整数提升](#整数提升)。例如：
```cpp
-true // 值为 -1
-false // 值为 0
-'a' // 值为 -97
```

此外，`-a` 表达式的值和 `a` 的值相反，但是类似与 `+a` 并不指代 `a` 这个对象，`-a` 并不会改变 `a` 的值。

### 按位取反

按位取反运算符的作用是对里面的基本表达式的每一位取反。例如：
```cpp
~42 // 值为 -43
```
假设 `int` 类型是32位的，`42` 的二进制表示是`0000 0000 0000 0000 0000 0000 0010 1010`，取反后的二进制表示是`1111 1111 1111 1111 1111 1111 1101 0101`，转换为十进制就是`-43`。

类似于正运算符和负运算符，按位取反运算符也会进行[整数提升](#整数提升)。例如：
```cpp
~true // 值为 -2
~false // 值为 -1
~'a' // 值为 -98
```

### 逻辑非

逻辑非运算符的作用是对里面的基本表达式取逻辑非，例如：
```cpp
!42 // 值为 0
```
逻辑非期待一个 `bool` 类型的值进行运算，所以这里 `42` 被转换为 `true`，然后取逻辑非，结果是 `false`。

## 加性表达式和乘性表达式

加性表达式和乘性表达式组成了 C++ 中，算数表达式的主要形式。

### 乘性表达式

乘性表达式的形式是
- ①`乘性表达式 * 一元表达式`
- ②`乘性表达式 / 一元表达式`
- ③`乘性表达式 % 一元表达式`
- ④`一元表达式`

根据中间的标点符号类型，乘性表达式的计算不同。`*`表示乘法，`/` 表示除法，`%` 表示取余。

```cpp
a * (b * c)
```
上面的例子里，`a` 是一个基本表达式，然后以上文④的形式单独组成了一个乘性表达式。`(b * c)` 也是一个基本表达式，然后 `a * (b * c)` 以上文①的形式组成了一个乘性表达式。

:::info
技术性地说，乘性表达式的形式中的①是 `乘性表达式 * 成员指针表达式`，②是 `乘性表达式 / 成员指针表达式`，以此类推。

从`成员指针表达式` 到 `一元表达式` 中间还有一层 `转换表达式`。

为了减少引入过多概念导致理解困难，这里简化了乘性表达式的形式。
:::

### 加性表达式

加性表达式的形式和乘性表达式很类似。加性表达式的形式是
- ①`加性表达式 + 乘性表达式`
- ②`加性表达式 - 乘性表达式`
- ③`乘性表达式`

根据中间的标点符号类型，加性表达式的计算不同。`+`表示加法，`-` 表示减法。

这时，我们已经能够组合出基本的四则运算了，例如
```cpp
a + b * c
```
利用一下上面的知识，我们可以对这个表达式做出如下的分析：
- `a`、`b`、`c` 都是基本表达式，其值分别是 `a`、`b`、`c` 所代表的对象的值。
- `b * c` 是一个乘性表达式，其值是 `b` 和 `c` 的乘法运算的结果。
- `a + b * c` 是一个加性表达式，其值是 `a` 和 `b * c` 的加法运算的结果。

可以画出一个这样的图示来理解
```mermaid
graph TB
    b-->ub["b(一元表达式)"]
    ub-->mb["b(乘性表达式)"]
    mb-->t[b * c]
    c-->uc["c(一元表达式)"]
    uc-->t[b * c]
    a-->ua["a(一元表达式)"]
    ua-->ma["a(乘性表达式)"]-->aa["a(加性表达式)"]
    aa-->x[a + b * c]
    t-->x
```

加性表达式的形式里面并不直接包含一元表达式，所以这里`a + b * c`的分析结果是唯一的：只能先计算 `b * c`，然后再计算 `a + b * c`。否则，就会出现`加性表达式 * 乘性表达式`的形式，这样无论是加性表达式还是乘性表达式都是不符合规定的。

### 整数的加减乘除与取余计算

在一般的情况下，C++ 中整数的加减乘除和数学上的整数运算是一致的。例如：
- `42 + 24`的值是`66`
- `42 - 24`的值是`18`
- `42 * 24`的值是`1008`
- `42 / 24`的值是`1`
- `42 % 24`的值是`18`。

:::info 整数除法
你可能已经忘记了整数除法的规则，这里简单复习一下。

整数除法的结果是整数商，还记得“7除以2得3余1”这样的说法吗，整数除法中`42 / 24`的结果是`1`，而不是`1.75`。这里提到的余数，也即是`42 % 24`得到的`18`这个结果。
:::

类似于正运算符，加减乘除和取余运算也会进行[整数提升](#整数提升)。例如：
```cpp
true + 2 // 值为 3
'a' + 2 // 值为 100
```

需要注意，`int` 类型并不是数学意义上的整数，是有范围的，当整数运算的结果超出了 `int` 类型的范围时，会发生溢出。对于 `int` 类型，溢出是非法的。因此，编译器可以认为绝对不会发生溢出，并依此生成代码，这将导致发生溢出时程序的行为不可预测。

## 移位表达式

移位表达式的形式是
- ①`移位表达式 << 加性表达式`
- ②`移位表达式 >> 加性表达式`
- ③`加性表达式`

其中，`<<` 表示左移，`>>` 表示右移。

### 移位表达式的计算
移位表达式计算的值是将 `<<` 或 `>>` 左边的值按照右边的值指定的比特数（位数）进行移位操作的结果。例如：
```cpp
42 << 2 // 值为 168
```
假设 `int` 是32位的，`42` 的二进制表示是 `0000 0000 0000 0000 0000 0000 0010 1010`，左移两位后的二进制表示是 `0000 0000 0000 0000 0000 0001 0100 0000`，转换为十进制就是 `168`。
当结果不超过范围时，你可以简单地认为左移`N`位就是乘以 `2^N`。相对的，右移`N`位就是除以 `2^N`（整数除法）。
如果左移的结果超过范围，例如：
```cpp
42 << 30
```
`42`的二进制表示是 `0000 0000 0000 0000 0000 0000 0010 1010`，左移31位后的二进制表示是 `1000 0000 0000 0000 0000 0000 0000 0000` （超出范围的位会被舍弃），最后这个结果转换为十进制就是 `-2147483648`。

任何情况下，如果移位表达式的右边的值是负数，或者超过了左边值的位数，那么这个表达式的行为是未定义的。

类似于加性表达式，移位表达式会进行[整数提升](#整数提升)。例如：
```cpp
true << 2 // 值为 4
'a' << 2 // 值为 388
```

:::tip
设计移位是因为在计算机中，移位操作是非常高效的。在一些情况下，移位操作可以取代乘法和除法，从而提高程序的性能。

然而，了解到这一点的程序员也会强迫自己一定要写出移位操作，这样的做法是不好的。现代编译器能够将整数乘除2的幂次方的操作优化为移位操作，所以不需要强迫自己写出移位操作。

程序员应当选择适合当前开发情况的代码，在功能开发期使用高可读性容易重构的代码，在维护优化期使用性能更高的代码。当然，我们最希望的事情是这两个目标能够并行不悖。
:::

## 关系表达式

**比较表达式**、**关系表达式**、**相等表达式**三者组成了 C++ 中的比较关系，它们的形式如下：

### 比较表达式
- ① `比较表达式 <=> 移位表达式`
- ② `移位表达式`

### 关系表达式
- ① `关系表达式 < 比较表达式`
- ② `关系表达式 > 比较表达式`
- ③ `关系表达式 <= 比较表达式`
- ④ `关系表达式 >= 比较表达式`
- ⑤ `比较表达式`

其中，`<` 表示小于，`>` 表示大于，`<=` 表示小于等于，`>=` 表示大于等于。

### 相等表达式
- ① `相等表达式 == 关系表达式`
- ② `相等表达式 != 关系表达式`
- ③ `关系表达式`

其中，`==` 表示等于，`!=` 表示不等于。

### 关系表达式与相等表达式的计算
比较表达式和关系表达式的结果都是 `bool` 类型。例如：
```cpp
42 < 24 // 值为 false
42 > 24 // 值为 true
42 <= 42 // 值为 true
24 >= 42 // 值为 false
42 == 42 // 值为 true
42 != 42 // 值为 false
```
如果两边的表达式的类型不同，C++ 会尝试将两边转换为类型大小较大的那个类型。例如：
```cpp
'a' < 42 // 值为 false
```
这里，`'a'` 被转换为 `int` 类型，然后再进行比较。`'a'`的ASCII码是65，所以这个比较的结果是 `65 < 42`，得到 `false`。

注意，不要连用两个比较运算符，例如`24 < a < 42`。这样的表达式会导致计算 `24 < a` 的结果，得到一个 `bool` 值，然后这个值（假定为`x`）再计算 `x < 42`。这样的计算中，`bool` 被转换为 `int` 类型（因为比较的右边是 `int` 类型），结果`x`要么是`0` 要么是 `1`，然后和 `42` 比较，这显然不会得到我们想要的结果。

### 比较表达式的计算
`<=>` 表示三路比较，`<=>` 的结果是一个整数，如果左边的值小于右边的值，结果是负数；如果左边的值等于右边的值，结果是0；如果左边的值大于右边的值，结果是正数。例如：
```cpp
(42 <=> 24) > 0 // 值为 true
(42 <=> 42) == 0 // 值为 true
(24 <=> 42) < 0 // 值为 true
```
::: info 
实际上，`int` 类型的三路比较的结果是一个 `std::strong_ordering` 类型的值，包括 `less`、`equal`、`greater` 三个值，这三个值可以与0做比较。这里为了方便理解，简化了三路比较的结果。
:::

## 按位逻辑表达式

按位逻辑表达式有三种：按位与、按位或和按位异或。

### 按位与
- ①`按位与表达式 & 相等表达式`
- ②`相等表达式`

### 按位异或
- ①`按位异或表达式 ^ 按位与表达式`
- ②`按位与表达式`
- 
### 按位或
- ①`按位或表达式 | 按位异或表达式`
- ②`按位异或表达式`

### 按位逻辑表达式的计算

按位逻辑表达式的计算是将 `&`、`^`、`|` 左右两边的值按每一位分别进行逻辑运算的结果。

对于一个比特而言：
- 按位与的结果是两个比特都为1时结果为1，否则为0。
- 按位或的结果是两个比特都为0时结果为0，否则为1。
- 按位异或的结果是两个比特相同时结果为0，否则为1。

例如：
```cpp
42 & 24 // 值为 8
42 | 24 // 值为 58
42 ^ 24 // 值为 50
```
`42` 的二进制表示是 `0000 0000 0000 0000 0000 0000 0010 1010`，`24` 的二进制表示是 `0000 0000 0000 0000 0000 0000 0001 1000`，按位与的结果是 `0000 0000 0000 0000 0000 0000 0000 1000`，转换为十进制就是 `8`。

按位逻辑表达式会进行[整数提升](#整数提升)。例如：
```cpp
true & 2 // 值为 2
'a' | 2 // 值为 99
```

## 逻辑表达式

逻辑表达式有两种：逻辑与和逻辑或。

### 逻辑与
- ①`逻辑与表达式 && 按位或表达式`
- ②`按位或表达式`

### 逻辑或
- ①`逻辑或表达式 || 逻辑与表达式`
- ②`逻辑与表达式`

### 逻辑表达式的计算

逻辑表达式的计算是将 `&&`、`||` 左右两边的值按照逻辑运算的结果。这会将左右两边的值转换为 `bool` 类型，然后进行逻辑运算。

其中：
- 逻辑与的结果是两个值都为 `true` 时结果为 `true`，否则为 `false`。
- 逻辑或的结果是两个值都为 `false` 时结果为 `false`，否则为 `true`。

例如：
```cpp
true && false // 值为 false
true || false // 值为 true
```

注意，逻辑表达式是短路的。例如：
```cpp
false && a
```
这个表达式的值一定是 `false`，因为逻辑与的左边是 `false`。此时，C++规定不会计算右边`a`的值，直接返回 `false`。类似的，如：
```cpp
true || a
```
这个表达式的值一定是 `true`，因为逻辑或的左边是 `true`。此时，C++规定不会计算右边`a`的值，直接返回 `true`。

在之后，当我们了解到表达式的副作用时，我们会进一步讨论逻辑表达式的短路。

:::tip 逻辑表达式的计算顺序
读者可以发现，从关系表达式到逻辑表达式，有着一层一层严格的组合关系。

例如：
```cpp
a || b && c > 0 || d < 0
```
这个表达式被唯一解释为如下图的计算过程：
```mermaid
graph TB
    a
    b
    c
    c-->cc0["c > 0"]
    z1[0]-->cc0
    b-->abc0["b && c > 0"]
    cc0-->abc0

    d-->od[d < 0]
    z2[0]-->od

    a-->abc1["a || b && c > 0"]
    abc0-->abc1

    abc1-->abc2["a || b && c > 0 || d < 0"]
    od-->abc2
```

现在正看着这个文档的你，可能会觉得这个计算顺序很明显。但是在开发的时候，每写一个表达式都要考虑计算顺序，是一件非常繁琐且降低效率的事情。

与其把时间消耗在反复训练以熟练掌握这个计算顺序，不如把时间消耗在提高代码质量上。在实际开发中，我们可以多用`()`括号，将复杂的组合表达式变为基本表达式。这样，不仅解决了计算顺序的问题，还可以提高代码的可读性。

例如，上面的表达式可以写成：
```cpp
a || (b && (c > 0)) || (d < 0)
```
这样计算顺序就变得非常明显了。

:::

## 条件表达式

C++ 中的条件表达式又叫做三目运算、三元表达式等名称，其形式是

`逻辑或表达式 ? 表达式 : 赋值表达式`

标点符号 `?` 和 `:` 是条件表达式的标志，为了方便表述，这里将 `?` 左边的表达式称为 操作数1，将 `:` 左边、`?` 右边的表达式称为 操作数2，将 `:` 右边的表达式称为 操作数3。

条件表达式的计算是先计算操作数1，如果操作数1转换到`bool`后的值`true`，则计算操作数2，否则计算操作数3（类似于逻辑表达式的短路行为，另一个操作数不会计算）。

整个表达式的值是操作数2或操作数3的值，取决于计算了哪一个操作数。

## 赋值表达式

赋值表达式的形式是：
- ①`条件表达式`
- ②`逻辑或表达式 = 赋值表达式`

以及一系列的复合赋值表达式：
- ③`逻辑或表达式 += 赋值表达式`
- ④`逻辑或表达式 -= 赋值表达式`
- ⑤`逻辑或表达式 *= 赋值表达式`
- ⑥`逻辑或表达式 /= 赋值表达式`
- ⑦`逻辑或表达式 %= 赋值表达式`
- ⑧`逻辑或表达式 <<= 赋值表达式`
- ⑨`逻辑或表达式 >>= 赋值表达式`
- ⑩`逻辑或表达式 &= 赋值表达式`
- ⑪`逻辑或表达式 ^= 赋值表达式`
- ⑫`逻辑或表达式 |= 赋值表达式`

### 赋值表达式的计算
赋值是 C++ 中一种操作的名称，对于 `int`、`bool`、`char` 这三种基本类型，赋值的操作是将一个对象的值改变为另一个值。例如：
```cpp
a = 42
```
这个表达式的作用是将 `a` 的值改变为 `42`。对于②形式的赋值表达式，其计算是先计算右边的赋值表达式，然后将计算结果赋值给左边的逻辑或表达式。

::: info 等于号
在数学中，等于号有很多含义，例如定义函数、表示等价、表示等于关系。但是在 C++ 中，等于号的含义是赋值。这个含义与数学中任何含义都不同，对于初学者需要注意。
:::

赋值表达式的值是赋值完成后 `=` 左边的值。例如：
```cpp
a = 42 // 值为 42，并表示 a 这个对象
```

这意味着你可以
```cpp
(a = 42) = 24
```
这里 `a` 先被赋值为 `42`，然后再被赋值为 `24`。这个表达式的值是 `24`。

注意，赋值表达式的组合方式和前面的表达式不同。例如，加性表达式的结构是

- ①`加性表达式 + 乘性表达式`

这里加性表达式在左边，乘性表达式在右边。而赋值表达式的结构是

- ②`逻辑或表达式 = 赋值表达式`

这里赋值表达式在左边，逻辑或表达式在右边。

考虑如下的表达式：
```cpp
a = b = 42
```
这个赋值表达式的结构实际上是
```mermaid
graph TB
    b-->be42["b = 42"]
    n[42]
    n-->be42
    a-->f["a = b = 42"]
    be42-->f
```
也即是说，这个表达式会先计算 `b = 42`，然后再计算 `a = b = 42`。也即从右往左计算的。

### 复合赋值表达式

复合赋值表达式是复合操作的赋值表达式，例如：
```cpp
a += 42
```
等价于
```cpp
a = a + 42
```

技术性地说，对于 `op` 运算符，`a op= b` 等价于 `a = a op b`。除了这里的 `a` 表达式只计算一次，其他的计算过程和先计算再赋值时是一样的。

### 副作用

在 C++ 中，表达式的计算可能会产生副作用。赋值表达式是目前介绍过的第一种可能产生副作用的表达式。例如：
```cpp
b = (a = 42) + 24
```
这个表达式除了会改变 `b` 的值，还会改变 `a` 的值。这里的 `a = 42` 是一个赋值表达式，它的值是 `42`，然后再计算 `42 + 24`，最后将结果 `66` 赋值给 `b`。

赋值表达式规定了先计算右边的表达式，再计算左边的表达式，最后进行赋值。这样的规定使得如`a += a += 1`这样的表达式是合法的，这里的计算过程是先计算右边的`a += 1`，得到这个表达式的值`x`，然后再计算左边的`a += x`。但显然这样的表达式的可读性比较糟糕，在开发中应当避免这样使用。

在前面逻辑表达式的短路中，我们提到了逻辑表达式的短路行为。这种短路行为会导致逻辑表达式的副作用不会发生。例如：
```cpp
false && (a = 42)
```
这个表达式的值是 `false`，并且 `a = 42` 不会计算，`a` 的值不会改变。类似的：
```cpp
true || (a = 42)
```
这个表达式的值是 `true`，并且 `a = 42` 不会计算，`a` 的值不会改变。

## 逗号表达式

逗号表达式的形式是

- ①`逗号表达式 , 赋值表达式`
- ②`赋值表达式`

这里将逗号表达式中，','的左边称为操作数1，右边称为操作数2。

逗号表达式的计算是先计算操作数1，然后计算操作数2，最后返回操作数2的值。例如：
```cpp
a = 42, a // 值为 42
```

逗号表达式也可以连续使用，例如：
```cpp
a = 42, b = 24, c = 66 // 值为 66
```
:::info
注意，在特定语境下，逗号不会被解释为逗号表达式。例如：
```cpp
int a = 42, b = 24;
```
这里的逗号不是逗号表达式，而是用来分隔不同的声明的。

除此之外还有函数调用、初始化列表等语境下，逗号也不会被解释为逗号表达式。这些内容会在后续章节中介绍。
:::

## 进一步理解初始化
在前文，我们提到初始化的概念，初始化的结构是：`类型 标识符 初始化器;`

之前我们认为初始化器是`= 字面量`，例如`int a = 42;`，`= 42`就是初始化器。现在，我们可以进一步理解初始化器，初始化器可以是`= 赋值表达式`。例如：
```cpp
int a = 42;
int b = 42 + a;
```
这里b的初始化器是`= 42 + a`，这个初始化器是`= 表达式`，这个生命会将`b`指代的对象初始化为`42 + a`的值。

初始化器中能出现赋值表达式（当然也因此而包括了赋值表达式所有的组件）。这意味着下列代码是合法的：
```cpp
int a = 42;
int b = a = 24;
```

此外，由于初始化器是`= 赋值表达式`，所以初始化器中不能出现逗号表达式。初始化器中的逗号有另外的含义，例如：
```cpp
int a = 42, b = 24;
```
这里的逗号不是逗号表达式，而是分隔了两个声明。这里分别声明了`a`和`b`，并分别初始化为`42`和`24`。

我们可以把以下两种形式统称为初始化声明
- `标识符`
- `标识符 = 赋值表达式`

那么，初始化就可以理解为

`类型 初始化声明 , 初始化声明 , 初始化声明 ... ;`

这样的结构，到此已经基本接近了完整的 C++ 初始化语法。

## 快速练习

<Choices 
    :questions="[
        {
            text: '下面的表达式的值是',
            code: '42 > 24 > 12',
            shuffleOptions: false,
            options: ['true', 'false', '语法错误'],
            answers: ['false']
        },
        {
            text: '下面的表达式的值是',
            code: 'true + true',
            shuffleOptions: false,
            options: ['2', '1','0', 'true', 'false', '语法错误'],
            answers: ['2']
        },
        {
            text: '下面的表达式的值是',
            code: '1 << \'\\n\'',
            shuffleOptions: false,
            options: ['1024', '128','10', '1', '0', '语法错误'],
            answers: ['1024']
        }
    ]"/>